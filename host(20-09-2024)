from flask import Flask, request, jsonify,session, send_file, send_from_directory,url_for
from flask_mysqldb import MySQL
from flask_wtf import FlaskForm
from wtforms import StringField, FileField, SelectField
from wtforms.validators import Optional
from datetime import datetime, timedelta
import bcrypt
import os
from werkzeug.utils import secure_filename
from flask_cors import CORS
import requests
from flask_excel import init_excel
import pandas as pd
from reportlab.lib.pagesizes import letter, A4
from reportlab.pdfgen import canvas
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Image, Spacer
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet,ParagraphStyle
import calendar
import logging
import traceback
from flask_mail import Mail, Message
import smtplib
import threading

app = Flask(__name__)
CORS(app)
init_excel(app)

app.config['SECRET_KEY'] = 'your_secret_key'
app.config['MYSQL_HOST'] = 'localhost'
app.config['MYSQL_USER'] = 'hrms'
app.config['MYSQL_PASSWORD'] = 'Atraya@12345'
app.config['MYSQL_DB'] = 'hrms'
app.config['WTF_CSRF_ENABLED'] = False

app.config['MAIL_SERVER'] = ''
app.config['MAIL_PORT'] = port
app.config['MAIL_USE_SSL'] = True
app.config['MAIL_USERNAME'] = ''
app.config['MAIL_PASSWORD'] = ''

mail = Mail(app)

UPLOAD_FOLDER = r'/home/fi2e8gs31z4n/projecthrms/personal_doc'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 10 * 1024 * 1024  # 5MB limit
ALLOWED_EXTENSIONS = {'pdf'}
image_extensions = {'jpg','jpeg','png'}

mysql = MySQL(app)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def image_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in image_extensions

def hash_password(password):
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

################################# login starts here ############################################

@app.route('/register', methods=['POST'])
def register():
    try:
        data = request.json
        
        # Extract data from the request
        employee_code = data.get('employee_code')
        full_name = data.get('full_name')
        role= data.get('role')  # Assuming role_name is passed in the request
        email = data.get('email')
        password = data.get('password')
        confirm_password = data.get('confirm_password')

        # Validate input data
        if None in [employee_code, full_name, role, email, password, confirm_password]:
            return jsonify({'success': False, 'message': 'All fields are required!'}), 400
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from registration where email = %s or employee_code = %s",(email,employee_code))
        user_email = cursor.fetchone()
        
        if user_email:
            return jsonify({'message':'Email or Employee Code already exists.'}), 400
        
        if password != confirm_password:
            return jsonify({'success': False, 'message': 'Passwords do not match!'}), 400

        # Hash the password
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

        # Insert new user with hashed password
        cursor.callproc('registration', (employee_code, full_name, role, email, hashed_password))
        mysql.connection.commit()
        cursor.close()
        
        cursor = mysql.connection.cursor()
        # Retrieve the user ID of the newly registered user
        cursor.execute("SELECT user_id, ref_role_id FROM registration WHERE employee_code = %s", (employee_code,))
        new_user = cursor.fetchone()

        if not new_user:
            return jsonify({'success': False, 'message': 'User registration failed!'}), 500

        user_id = new_user[0]
        # Insert role mapping into the role_mapping table
        cursor.callproc('insert_role_mapping', [user_id, role])
        mysql.connection.commit()
        cursor.close()

        # Return success response with message and data
        return jsonify({'success': True, 'message': 'User registered successfully!', 'data': {
            'employee_code': employee_code,
            'full_name': full_name,
            'role': new_user[1],
            'ref_role_id': new_user[1],
            'email': email
        }}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


@app.route('/login', methods=['POST'])
def login():
    try:
        data = request.json
        email = data.get('email') 
        password = data.get('password')

        # Connect to the MySQL database
        cursor = mysql.connection.cursor()
        # Retrieve user data by email or employee code
        cursor.callproc('login' ,[email])
        user = cursor.fetchone()

        if user:
            # Check if the password matches the hashed password
            if bcrypt.checkpw(password.encode('utf-8'), user[5].encode('utf-8')):
                # Store user data in session
                session['user'] = {
                    'user_id': user[0],
                    'full_name': user[1],
                    'email': user[2],
                    'ref_role_id': user[3],
                    'employee_code': user[4],  # Include employee code in the session data
                    'role': user[6]  # Include role information in the session data
                }
                cursor.close()

                # Return success response with user data and role-specific message
                role_specific_message = {
                    1: 'Management login successful!',
                    2: 'HR login successful!',
                    3: 'Employee login successful!'   
                }
                message = role_specific_message.get(session['user']['ref_role_id'], 'Unknown user role')

                return jsonify({'success': True, 'message': message, 'data': session['user']}), 200
            else:
                cursor.close()
                return jsonify({'success': False, 'message': 'Invalid email or password'}), 200
        else:
            cursor.close()
            return jsonify({'success': False, 'message': 'User not found'}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

    
@app.route('/forgot_password', methods=['GET','POST'])
def forgot_password():
    try:
        data = request.json
        email = data.get('email')
        new_password = data.get('new_password')
        confirm_password = data.get('confirm_password')
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from registration where email = %s",(email,) )
        user = cursor.fetchone()
        
        if not user:
            return jsonify({'message':'email not found'}), 400

        if new_password != confirm_password:
            return jsonify({'message': 'New password and confirm password do not match'}), 400
        
        hashed_password = hash_password(new_password)
        hashed_confirm = hash_password(confirm_password)
        
        cursor.callproc("forgot_password", (hashed_password,hashed_confirm ,email))
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({"status":True,'message':"Password changed successfully."}),200
    except Exception as e:
        return jsonify({'status':False,'message':f'{str(e)}'}),200
    
@app.route('/logout', methods=['POST'])
def logout():
    try:
        # Clear the session
        session.clear()
        
        # Prepare the response to prevent caching
        response = jsonify({"success": True, "message": "Logged out successfully"})
        
        return response
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500
    
################################# login ends here ############################################

class PersonalInformationForm(FlaskForm):
    full_name = StringField('Full Name', validators=[Optional()])
    address = StringField('Address', validators=[Optional()])
    gender = StringField('Gender', validators=[Optional()])
    age = StringField('Age', validators=[Optional()])
    dob = StringField('Date of Birth (DD-MM-YYYY)', validators=[Optional()])
    role = SelectField('Role', choices=[])
    email_id = StringField('Email Id', validators=[Optional()])
    mobile_number = StringField('Mobile Number', validators=[Optional()])
    highest_qualification = SelectField('Highest Qualification', choices=[])
    graduation_year = StringField('Graduation Year', validators=[Optional()])
    work_experience = StringField('Work Experience', validators=[Optional()])
    department = SelectField('Department', choices=[])
    marriage = StringField('Marital Status', validators=[Optional()])
    bank_name = SelectField('Bank Name', choices=[])
    bank_acc_no = StringField('Bank Account Number', validators=[Optional()])
    bank_ifsc_code = StringField('Bank IFSC code',  validators=[Optional()])
    date_of_joining = StringField('Date of Joining', validators=[Optional()])
    employee_code = StringField('Employee ID', validators=[Optional()])
    resume = FileField('Resume', validators=[Optional()])
    certificates = FileField('Certificates', validators=[Optional()])
    identity_proof = FileField('Identity Proof', validators=[Optional()])
    profile_image = FileField('Profile Image', validators=[Optional()])
    status = StringField('Status', validators=[Optional()])
    institute_name = StringField('Institute Name',validators=[Optional()])
    company_name = StringField('company name', validators=[Optional()])
    branch = StringField('Bank Branch',  validators=[Optional()])

    def __init__(self, *args, **kwargs):
        super(PersonalInformationForm, self).__init__(*args, **kwargs)
        
        # Populate choices for SelectFields from API endpoints
        self.role.choices = self.fetch_choices('/role_name')
        self.department.choices = self.fetch_choices('/department_name')
        self.bank_name.choices = self.fetch_choices('/bank_name')
        self.highest_qualification.choices = self.fetch_choices('/qualification_name')

    def fetch_choices(self, endpoint):
        response = requests.get(f'https://canteencard.in/projecthrms/{endpoint}')
        if response.status_code == 200:
            try:
                data = response.json().get('list', [])
                choices = [(value, value) for value in data]
                return choices
            except ValueError as e:
                print(f"Error decoding JSON: {e}")
                return []
        else:
            print(f"Error fetching choices. Status code: {response.status_code}")
            return []

@app.route('/bank_name', methods=['GET'])
def bank_name():
    cursor = mysql.connection.cursor()
    cursor.callproc("master_bankname")
    bank = cursor.fetchall()
    cursor.close()
    return jsonify({"list": [name[0] for name in bank]}), 200
import urllib.parse
@app.route("/branches/<bank_name>", methods = ['GET'])
def branches(bank_name):
    try:
        decode_bank_name = urllib.parse.unquote(bank_name)
        cursor = mysql.connection.cursor()
        cursor.callproc('master_bank_branch',[decode_bank_name])
        branch = cursor.fetchall()
        # cursor.close()
        
        branch_list = [data[0] for data in branch]
        return jsonify({'status':True,'data':branch_list,'message':f'Displaying branches of {decode_bank_name}.'}), 200
    except Exception as e:
        return jsonify({'status':False,'message':f'{str(e)}.'}),500
    
@app.route('/ifsc_code/<bank_name>/<branch>', methods=['GET'])
def ifsc_code(bank_name,branch):
    try:
        decode_bank_name = urllib.parse.unquote(bank_name)
        decode_branch = urllib.parse.unquote(branch)
        cursor = mysql.connection.cursor()
        cursor.callproc('master_ifsc',[decode_bank_name,decode_branch])
        ifsc = cursor.fetchall()
        cursor.close()
        
        ifsc_list = [data[0] for data in ifsc]
        return jsonify({"data": ifsc_list,'status':True,'message':f"Displaying IFSC code of {decode_bank_name}, {decode_branch}"}), 200
    except Exception as e:
        return jsonify({'status':False,'message':f'{str(e)}.'}),500

@app.route('/department_name', methods=['GET'])
def department_name():
    cursor = mysql.connection.cursor()
    cursor.callproc("master_department")
    department = cursor.fetchall()
    cursor.close()
    return jsonify({"list": [name[0] for name in department]}), 200

@app.route('/role_name', methods=['GET'])
def role_name():
    cursor = mysql.connection.cursor()
    cursor.callproc("master_roles")
    role = cursor.fetchall()
    cursor.close()
    return jsonify({"list": [name[0] for name in role]}), 200

@app.route('/qualification_name', methods=['GET'])
def qualification_name():
    cursor = mysql.connection.cursor()
    cursor.callproc("master_qualification")
    qualify = cursor.fetchall()
    cursor.close()
    return jsonify({"list": [name[0] for name in qualify]}), 200

################################# employee info starts here ############################################
def send_async_email(app, msg):
    with app.app_context():
        mail.send(msg)

def send_welcome_email(email_id, full_name):
    try:
        msg = Message('Welcome to Atraya Technologies',
                      sender='atrayatech@canteencard.in',
                      recipients=[email_id])
        msg.body = f'Dear {full_name},\n\nWelcome to Atraya Technologies Pvt. Ltd. \nWe are excited to have you on board.\n\nBest regards,\nAtraya Technologies Pvt. Ltd.'

        # Send email asynchronously
        thr = threading.Thread(target=send_async_email, args=[app, msg])
        thr.start()

        print(f"Welcome email sent to {email_id}")
    except Exception as e:
        print(f"Error sending welcome email to {email_id}: {str(e)}")
        raise  # Raise the exception to propagate it and see the error traceback

# @app.route('/send_email/<email_id>/<full_name>')
# def send_email(email_id, full_name):
#     result = send_welcome_email_task(email_id, full_name)
#     return jsonify(result) 
    
@app.route('/personal_information', methods=['POST'])
def personal_information():
    try:
        form = PersonalInformationForm()

        if form.validate_on_submit():
            data = form.data
            # Retrieve form data
            employee_code = data['employee_code']
            full_name = data['full_name']
            address = data['address']
            gender = data['gender']
            age = data['age']
            dob = data['dob']
            role = data['role']
            email_id = data['email_id']
            mobile_number = data['mobile_number']
            highest_qualification = data['highest_qualification']
            graduation_year = data['graduation_year']
            work_experience = data['work_experience']
            department = data['department']
            marriage = data['marriage']
            bank_name = data['bank_name']
            bank_acc_no = data['bank_acc_no']
            bank_ifsc_code = data['bank_ifsc_code']
            date_of_joining = data['date_of_joining']
            employee_code = data['employee_code']
            status = 1 
            company_name = data['company_name']
            institute_name = data['institute_name']
            bank_branch = data['branch']
            
            # Handle file uploads
            profile_image = request.files.get('profile_image')
            certificates = request.files.get('certificates')
            identity_proof = request.files.get('identity_proof')
            resume = request.files.get('resume')
            
            cursor = mysql.connection.cursor()
            cursor.execute("SELECT email FROM registration WHERE employee_code = %s", (employee_code,))
            user_check = cursor.fetchone()
            
            if not user_check:
                return jsonify({"status":False,"message": "Form validation failed","error":"Employee not found in registration."}),400

            if user_check[0] != email_id:
                return jsonify({"status":False,"message": "Form validation failed","error":"Employee email not matching."}),400
            
            cursor.execute("SELECT * FROM personal_information WHERE employee_code = %s", (employee_code,))
            user = cursor.fetchone()
            
            if user:
                return jsonify({"status":False,"message": "Form validation failed","error":"Employee with this ID already exists."}),400
        
            # Save the file to the server
            image_filename = None
            if profile_image and image_file(profile_image.filename):
                # Save profile image with filename format employee_code_image.extension
                image_extension = os.path.splitext(profile_image.filename)[1]  # Get file extension
                image_filename = f"{employee_code}_image{image_extension}"
                profile_image_path = os.path.join(app.config['UPLOAD_FOLDER'], image_filename)
                profile_image.save(profile_image_path)
            
            certificates_filename = None
            if certificates and allowed_file(certificates.filename):
                certificates_extension = os.path.splitext(certificates.filename)[1]
                certificates_filename = f"{employee_code}_certificate{certificates_extension}"
                certificates.save(os.path.join(app.config['UPLOAD_FOLDER'], certificates_filename))
                
            proof_filename = None
            if identity_proof and allowed_file(identity_proof.filename):
                identity_proof_extension = os.path.splitext(identity_proof.filename)[1]
                proof_filename = f"{employee_code}_identity_proof{identity_proof_extension}"
                identity_proof.save(os.path.join(app.config['UPLOAD_FOLDER'], proof_filename))
            
            resume_filename = None
            if resume and allowed_file(resume.filename):
                resume_extension = os.path.splitext(resume.filename)[1]
                resume_filename = f"{employee_code}_resume{resume_extension}"
                resume.save(os.path.join(app.config['UPLOAD_FOLDER'], resume_filename))

            # Insert data into database
            cursor = mysql.connection.cursor()
            cursor.callproc('insert_personal_info', (data['full_name'], data['address'], data['gender'], data['age'], data['dob'], data['role'], email_id, data['mobile_number'],
                data['highest_qualification'], data['graduation_year'], data['work_experience'], data['department'], certificates_filename,
                proof_filename, image_filename, data['marriage'], data['bank_name'], data['bank_acc_no'], data['bank_ifsc_code'],
                data['date_of_joining'], employee_code, resume_filename, 1, data['company_name'], data['institute_name'], data['branch']
            ))

            mysql.connection.commit()
            
            cursor.callproc('response_personal_info',(employee_code,))
            personal_data = cursor.fetchone()
            cursor.close()
            
            if personal_data:
                # date_str = datetime.strptime(personal_data[19],'%Y-%m-%d')
                data = {
                        "employee_code" : personal_data[1],
                        "full_name" : personal_data[2],
                        "address" : personal_data[7],
                        "gender" : personal_data[6],
                        "age" : personal_data[4],
                        "dob" : personal_data[5],
                        "role" : personal_data[13],
                        "mobile_number" : personal_data[8],
                        "highest_qualification" : personal_data[10],
                        "graduation_year" : personal_data[11],
                        "work_experience" : personal_data[12],
                        "department" : personal_data[14],
                        "marriage" : personal_data[9],
                        "bank_name" : personal_data[15],
                        "branch" : personal_data[16],
                        "bank_acc_no" : personal_data[17],
                        "bank_ifsc_code" : personal_data[18],
                        "date_of_joining" : personal_data[19],
                        "email_id" : personal_data[3],
                        "certificates" : personal_data[20],
                        "identity_proof" : personal_data[21],
                        "resume" : personal_data[23],
                        "profile_image" : personal_data[22],
                        "status" : personal_data[26],
                        "company_name": personal_data[24], 
                        "institute_name" : personal_data[25]
                    }
            
            response_data = {
                "status" : True,
                "message" : "Employee added successfully.",
                "data" : data
            }
          
            send_welcome_email(email_id, full_name)

            return jsonify(response_data), 200
        else:
            errors = {field: error for field, error in form.errors.items()}
            return jsonify({"status":False,"message": "Form validation failed", "errors": errors}), 400
    except Exception as e:
        return jsonify({"status":False,"message":'Error occurred.',"error":str(e)}),500

@app.route('/personal_doc/<filename>')
def uploaded_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

@app.route('/update_personal_information/<employee_code>', methods=['GET'])
def edit_employee(employee_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("""SELECT employee_code,full_name, email_Id, age, gender, address, dob, mobile_number,marriage, 
                highest_qualification, graduation_year, work_experience, role, department, bank_name, bank_acc_no, 
                bank_ifsc_code, date_of_joining, status, certificates, identity_proof, profile_image, resume,company_name,institute_name,bank_branch 
                    FROM personal_information WHERE employee_code = %s""", (employee_code,))
        employee_data = cursor.fetchone()
        cursor.close()

        if employee_data:
            # Unpack the values from the tuple into individual variables
            (employee_code, full_name, email_id, age, gender, address,dob, mobile_number, marriage, highest_qualification, 
            graduation_year,work_experience, role, department, bank_name, bank_acc_no, bank_ifsc_code, date_of_joining, 
            status,certificates,identity_proof,profile_image, resume,company_name,institute_name,bank_branch) = employee_data
            
            # Generate URLs for each file using Flask's url_for function
            certificates_url = url_for('uploaded_file', filename=certificates, _external=True) if certificates else None
            identity_proof_url = url_for('uploaded_file', filename=identity_proof, _external=True) if identity_proof else None
            profile_image_url = url_for('uploaded_file', filename=profile_image, _external=True) if profile_image else None
            resume_url = url_for('uploaded_file', filename=resume, _external=True) if resume else None
            
            status_label = "Active" if status == 1 else "Inactive"

            employee_dict = {
                "employee_code": employee_code,
                "full_name": full_name,
                "address": address,
                "email_id": email_id,
                "age": age,
                "gender": gender,
                "dob": dob,
                "mobile_number": mobile_number,
                "marriage": marriage,
                "highest_qualification": highest_qualification,
                "graduation_year": graduation_year,
                "work_experience": work_experience,
                "role": role,
                "department": department,
                "bank_name": bank_name,
                "bank_acc_no": bank_acc_no,
                "bank_ifsc_code": bank_ifsc_code,
                "date_of_joining": date_of_joining,
                "status": status_label,
                "company_name": company_name, 
                "institute_name" : institute_name,
                # Include file URLs in the dictionary
                "certificates": certificates_url,
                "identity_proof": identity_proof_url,
                "profile_image": profile_image_url,
                "resume": resume_url,
                "branch":bank_branch
            }

            return jsonify(employee_dict),200
        else:
            return jsonify({"status": False, "error": "Employee not found"}), 400
    except Exception as e:
        return jsonify({"status":False,"message":f'Error ocurred : {str(e)}.'}),500

@app.route('/update_personal_information/<employee_code>', methods=['PUT'])
def update_personal_information(employee_code):
    # form = PersonalInformationForm()

    # if form.validate_on_submit():
    #     data = form.data
    try:
        # Retrieve form data
        full_name = request.form.get('full_name')
        address = request.form.get('address')
        gender = request.form.get('gender')
        age = request.form.get('age')
        dob = request.form.get('dob')
        role = request.form.get('role')
        email_id = request.form.get('email_id')
        mobile_number = request.form.get('mobile_number')
        highest_qualification = request.form.get('highest_qualification')
        graduation_year = request.form.get('graduation_year')
        work_experience = request.form.get('work_experience')
        department = request.form.get('department')
        marriage = request.form.get('marriage')
        bank_name = request.form.get('bank_name')
        bank_acc_no = request.form.get('bank_acc_no')
        bank_ifsc_code = request.form.get('bank_ifsc_code')
        date_of_joining = request.form.get('date_of_joining')
        status = 1
        company_name = request.form.get('company_name')
        institute_name = request.form.get('institute_name')
        bank_branch = request.form.get('branch')

        
        # Handle file uploads
        profile_image = request.files.get('profile_image')
        certificates = request.files.get('certificates')
        identity_proof = request.files.get('identity_proof')
        resume = request.files.get('resume')
    
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT * FROM personal_information WHERE employee_code = %s", (employee_code,))
        user = cursor.fetchone()
        
        if not user:
            return jsonify({"status":False,"message": "Form validation failed","error":"Employee ID not found."}),404
        
        # Existing file names
        existing_profile_image = user[22]  # Assuming profile_image is at index 18 in the database table
        existing_certificates = user[20]  # Assuming certificates is at index 11
        existing_identity_proof = user[21]  # Assuming identity_proof is at index 12
        existing_resume = user[23]

        # Save the file to the server only if new files are uploaded
        if profile_image and image_file(profile_image.filename):
            image_extension = os.path.splitext(profile_image.filename)[1]
            image_filename = f"{employee_code}_image{image_extension}"
            profile_image_path = os.path.join(app.config['UPLOAD_FOLDER'], image_filename)
            profile_image.save(profile_image_path)
        else:
            image_filename = existing_profile_image

        if certificates and allowed_file(certificates.filename):
            certificates_extension = os.path.splitext(certificates.filename)[1]
            certificates_filename = f"{employee_code}_certificate{certificates_extension}"
            certificates.save(os.path.join(app.config['UPLOAD_FOLDER'], certificates_filename))
        else:
            certificates_filename = existing_certificates

        if identity_proof and allowed_file(identity_proof.filename):
            identity_proof_extension = os.path.splitext(identity_proof.filename)[1]
            proof_filename = f"{employee_code}_identity_proof{identity_proof_extension}"
            identity_proof.save(os.path.join(app.config['UPLOAD_FOLDER'], proof_filename))
        else:
            proof_filename = existing_identity_proof

        if resume and allowed_file(resume.filename):
            resume_extension = os.path.splitext(resume.filename)[1]
            resume_filename = f"{employee_code}_resume{resume_extension}"
            resume.save(os.path.join(app.config['UPLOAD_FOLDER'], resume_filename))
        else:
            resume_filename = existing_resume
       
        cursor.callproc('update_personal_information', (
            employee_code, full_name, address, gender, age, dob, role, email_id, mobile_number, highest_qualification,
            graduation_year, work_experience, department, marriage, bank_name, bank_acc_no, bank_ifsc_code, date_of_joining,
            status, company_name, institute_name, bank_branch, certificates_filename, proof_filename, image_filename, resume_filename
        ))
        
        mysql.connection.commit()
        
        cursor.callproc('response_personal_info',(employee_code,))
        personal_data = cursor.fetchone()
        cursor.close()
        
        if personal_data:
            data = {
                        "employee_code" : personal_data[1],
                        "full_name" : personal_data[2],
                        "address" : personal_data[7],
                        "gender" : personal_data[6],
                        "age" : personal_data[4],
                        "dob" : personal_data[5],
                        "role" : personal_data[13],
                        "mobile_number" : personal_data[8],
                        "highest_qualification" : personal_data[10],
                        "graduation_year" : personal_data[11],
                        "work_experience" : personal_data[12],
                        "department" : personal_data[14],
                        "marriage" : personal_data[9],
                        "bank_name" : personal_data[15],
                        "branch" : personal_data[16],
                        "bank_acc_no" : personal_data[17],
                        "bank_ifsc_code" : personal_data[18],
                        "date_of_joining" : personal_data[19],
                        "email_id" : personal_data[3],
                        "certificates" : personal_data[20],
                        "identity_proof" : personal_data[21],
                        "resume" : personal_data[23],
                        "profile_image" : personal_data[22],
                        "status" : personal_data[26],
                        "company_name": personal_data[24], 
                        "institute_name" : personal_data[25]
                    }
        
        return jsonify({"status":True,
            "message": "Update saved successfully",
            "data":data}), 200
    except Exception as e:
        return jsonify({'status':False,'message':f'Error occurred: {str(e)}.'}),500

    
@app.route('/delete_employee/<employee_code>',methods=["DELETE"])
def delete_employee(employee_code):
    cursor = mysql.connection.cursor()
    cursor.execute("select * from personal_information where employee_code = %s",(employee_code,))
    user = cursor.fetchone()
    
    if not user:
        return jsonify({"status":False,"message":"Form validation error","error":"Employee ID not found."}),404
    
    cursor.execute('UPDATE personal_information set status = 0, is_active = 0 where employee_code = %s',(employee_code,))
    mysql.connection.commit()
    cursor.close()
    
    return jsonify({"status":True,
                    "message":"Employee deactivated successfully",
                    "data": employee_code}),200

  
@app.route('/personal_information_list/<employee_code>', methods=["GET"])
def personal_information_list(employee_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.callproc('getpersonalinfo_by_emp_code',[employee_code])
        data_all = cursor.fetchone()
        cursor.close()
        
        if not data_all:
            return jsonify({'status':False,'message':'No data found.'}),400

        if data_all:
            try:
                joining_date_str = datetime.strptime(data_all[17],'%Y-%m-%d')
                dob_date_str = datetime.strptime(data_all[6],'%Y-%m-%d')
            except ValueError:
                joining_date_str = datetime.strptime(data_all[17],'%d-%m-%Y')
                dob_date_str = datetime.strptime(data_all[6],'%d-%m-%Y')
            reg_dict = {
                "employee_code": data_all[0],
                "full_name": data_all[1],
                "email_id": data_all[2],
                "age": data_all[3],
                "gender": data_all[4],
                "address": data_all[5],
                "dob": dob_date_str.strftime('%d-%m-%Y'),
                "mobile_number": data_all[7],
                "marriage": data_all[8],
                "highest_qualification": data_all[9],
                "graduation_year": data_all[10],
                "work_experience": data_all[11],
                "role": data_all[12],
                "department": data_all[13],
                "bank_name": data_all[14],
                "bank_acc_no": data_all[15],
                "bank_ifsc_code": data_all[16],
                "date_of_joining": joining_date_str.strftime('%d-%m-%Y'),
                "status": data_all[18],
                "company_name":data_all[19],
                "institute_name" : data_all[20],
                "certificates" : data_all[21],
                "identity_proof" : data_all[22],
                "profile_image" : data_all[23],
                "resume" : data_all[24],
                "branch" : data_all[25]
            }

        return jsonify({"status": True, "message": "Displaying the active employees", "data": reg_dict}), 200
    except Exception as e :
        return jsonify({"status":False,"message":f'error occurred: str{e}'}),500

@app.route('/personal_information_pagination', methods=["GET"])
def personal_information_pagination():
    try:
        cursor = mysql.connection.cursor()

        # Get pagination parameters from the request
        total_records = request.args.get('total_records', type=int)
        per_page = request.args.get('per_page', default=10, type=int)

        if total_records is None:
            # Fetch all records from the database
            cursor.execute("""SELECT COUNT(*) FROM personal_information WHERE is_active = 1""")
            total_records = cursor.fetchone()[0]

        # Calculate the total number of pages
        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1

        # Extract page number from the request
        page = request.args.get('page', default=1, type=int)

        # If the page is greater than the total pages, return empty data
        if page > total_pages:
            return jsonify({
                "status": False,
                "message": "Page not found",
                "data": [],
                "page": page,
                "per_page": per_page,
                "total_records": total_records,
                "total_pages": total_pages
            }), 200

        # Calculate the offset
        offset = (page - 1) * per_page

        # If it's the last page and there are fewer records than per_page, adjust per_page
        if page == total_pages and total_records % per_page != 0:
            per_page = total_records % per_page

        # Execute stored procedure with pagination
        cursor.callproc('GetPersonalInformationPagination', [per_page, offset])
        data = cursor.fetchall()

        cursor.close()

        # Convert data to JSON format
        result = []
        for row in data:
            # try:
            joining_date_str = datetime.strptime(row[17],'%Y-%m-%d')
            dob_date_str = datetime.strptime(row[6],'%Y-%m-%d')
            # except ValueError:
            #     joining_date_str = datetime.strptime(row[17],'%d-%m-%Y')
            #     dob_date_str = datetime.strptime(row[6],'%d-%m-%Y')
            row_dict = {
                "employee_code": row[0],
                "full_name": row[1],
                "email_id": row[2],
                "age": row[3],
                "gender": row[4],
                "address": row[5],
                "dob": dob_date_str.strftime('%d-%m-%Y'),
                "mobile_number": row[7],
                "marriage": row[8],
                "highest_qualification": row[9],
                "graduation_year": row[10],
                "work_experience": row[11],
                "role": row[12],
                "department": row[13],
                "bank_name": row[14],
                "bank_acc_no": row[15],
                "bank_ifsc_code": row[16],
                "date_of_joining":joining_date_str.strftime('%d-%m-%Y'),
                "status": row[18],
                "company_name": row[19],
                "institute_name": row[20],
                "certificates": row[21],
                "identity_proof": row[22],
                "profile_image": row[23],
                "resume": row[24],
                "branch": row[25]
            }
            result.append(row_dict)

        # Return paginated data along with metadata
        return jsonify({
            "status": True,
            "message": "Displaying paginated data",
            "page": page,
            "per_page": per_page,
            "total_records": total_records,
            "total_pages": total_pages,
            "data": result
        }), 200

    except Exception as e:
        return jsonify({
            "status": False,
            "message": str(e),
            "data": [],
            "page": page,
            "per_page": per_page,
            "total_records": total_records,
            "total_pages": total_pages
        }), 500

##################################### Employee info ends here ######################################################

#################################### Attendance Management starts here #################################################

@app.route('/attendance_management_list',methods = ['GET'])
def attendance_pagination():
    total_records = request.args.get('total_records', type=int)
    per_page = request.args.get('per_page', default=10,type=int)
    
    if total_records is None:
        # Fetch all records from the database
        cursor = mysql.connection.cursor()
        cursor.execute("""SELECT COUNT(*) FROM attendance_management WHERE is_active = 1""")
        total_records = cursor.fetchone()[0]
        
    # Calculate the total number of pages
    total_pages = total_records // per_page
    if total_records % per_page != 0 :
        total_pages += 1
    
    # Extract page number from the request    
    page = request.args.get('page', default=1, type=int)
    
    # If the page is greater than the total pages, return empty data
    if page > total_pages:
        return jsonify({'status':False,'message':'Page not found','data':[]}), 200
    
    # Calculate the offset
    offset = (page - 1) * per_page
    
    # If it's the last page and there are fewer records than per_page, adjust per_page
    if page == total_pages and total_records % per_page != 0:
        per_page = total_records % per_page
        
    cursor = mysql.connection.cursor()
    cursor.callproc("get_attendance_pagination",[per_page,offset])
    data = cursor.fetchall()
    cursor.close()
    
    atd_list = []
    for atd in data:
        atd_d = {
            'ref_employee_code':atd[0],
            'date':atd[1].strftime('%d-%m-%Y'),
            'check_in':atd[2],
            'check_out':atd[3],
            'working_hours':atd[4],
            'status':atd[5],
            "shift":atd[6],
            "id":atd[7],
            'full_name':atd[8]
        }
        atd_list.append(atd_d)
        
    return jsonify({'status':True,'message':'Displaying paginated data.','page':page,'per_page':per_page,
                    'total_records':total_records,'total_pages':total_pages,'data':atd_list}),200
        

@app.route('/prefill_attendance_management_list/<ref_employee_code>/<date>', methods=['GET'])
def attendance_management_list(ref_employee_code,date):
    
    cursor = mysql.connection.cursor()
    cursor.execute("""select am.ref_employee_code,am.date,am.check_in,am.check_out,am.working_hours,am.status,am.shift, pi.full_name from attendance_management as am 
    join personal_information as pi on am.ref_employee_code = pi.employee_code
                   where am.ref_employee_code = %s and am.is_active = 1 and am.date = %s""",(ref_employee_code,date))
    user = cursor.fetchone()
    
    if not user:
        return jsonify({'status':False,'message':'Employee code is inactive or not found.'})
    cursor.execute("""
            SELECT COUNT(*) FROM attendance_management 
            WHERE ref_employee_code = %s AND date = %s AND status = 'Leave'
        """, (ref_employee_code, date))
    record_count = cursor.fetchone()[0]

    if record_count > 0:
        return jsonify({"status": False, "message": "Employee is on leave."}), 200
    
    mysql.connection.commit()
    cursor.close()
    if user:
        data = {"ref_employee_code" : user[0],
            "date" : date,
            "check_in" : user[2],
            "check_out" : user[3],
            "working_hours" : user[4],
            "status": user[5],
            "shift":user[6],
            'full_name':user[7]
            }
 
    return jsonify({"status":True,"message":f"displaying data of employee code {ref_employee_code}","data":data}),200
    
@app.route('/attendance_management', methods=['POST'])
def attendance_management():
    try:
        data = request.json
        if not data:
            return jsonify({"status": False, "message": "No JSON data provided"}), 400

        ref_employee_code = data.get('ref_employee_code')
        date = datetime.strptime(data.get('date'), '%Y-%m-%d').date()
        check_in = data.get('check_in')
        check_out = data.get('check_out')
        shift = data.get('shift')
        
        cursor = mysql.connection.cursor()
        # Check if employee is marked as 'Absent' on the date
        cursor.execute("""
            SELECT COUNT(*) FROM attendance_management 
            WHERE ref_employee_code = %s AND date = %s AND status = 'Leave'
        """, (ref_employee_code, date))
        record_count = cursor.fetchone()[0]

        if record_count > 0:
            return jsonify({"status": False, "message": "Employee is on leave."}), 400
        
        # Check if attendance is already recorded for the employee on the date
        cursor.execute("""
            SELECT COUNT(*) FROM attendance_management 
            WHERE ref_employee_code = %s AND date = %s
        """, (ref_employee_code, date))
        record_count = cursor.fetchone()[0]

        if record_count > 0:
            return jsonify({"status": False, "message": "Attendance already recorded for this employee for this date."}), 400
        
        # Calculate working hours
        working_hours = None
        if check_in and check_out:
            # Parse check_in and check_out as time objects
            check_in_time = datetime.strptime(check_in, '%H:%M').time()
            check_out_time = datetime.strptime(check_out, '%H:%M').time()
            
            # Determine if the shift spans midnight
            if check_out_time < check_in_time:
                # Check_out time is earlier than check_in time, so we add 24 hours to check_out time
                check_out_datetime = datetime.combine(date, check_out_time) + timedelta(days=1)
                check_in_datetime = datetime.combine(date, check_in_time)
                working_hours_seconds = (check_out_datetime - check_in_datetime).total_seconds()
            else:
                # Calculate time difference directly if check_out time is later than check_in time
                check_out_datetime = datetime.combine(date, check_out_time)
                check_in_datetime = datetime.combine(date, check_in_time)
                working_hours_seconds = (check_out_datetime - check_in_datetime).total_seconds()

            # Convert seconds to time format
            working_hours = str(timedelta(seconds=working_hours_seconds))
            
            # Insert attendance record
            cursor.callproc('insert_attendance_management', (ref_employee_code, date, check_in, check_out, working_hours,'Present',shift))
            
        elif check_in:
            # Insert record with only check_in time
            working_hours = '00:00:00'  # No working hours when check_out is not provided
            cursor.callproc('insert_attendance_management', (ref_employee_code, date, check_in, None, None,'Present',shift))
            # cursor.execute("""
            #     INSERT INTO attendance_management (ref_employee_code, date, check_in, status,shift)
            #     VALUES (%s, %s, %s, 'Present', %s)
            # """, (ref_employee_code, date, check_in,shift))

        elif not check_out and not check_in:
            # Mark employee as absent
            cursor.execute("""
                INSERT INTO attendance_management (ref_employee_code, date, status) 
                VALUES (%s, %s, 'Absent')
            """, (ref_employee_code, date))

        mysql.connection.commit()
        cursor.callproc('retrieve_attendance_data',(ref_employee_code,date))
        attend_data = cursor.fetchone()
        cursor.close()
        
        if attend_data:
            data = {
                'date': attend_data[2].strftime("%d-%m-%Y"),
                "check_in": attend_data[3],
                'check_out': attend_data[4],
                'ref_employee_code': attend_data[1],
                'working_hours': attend_data[5],
                'shift':attend_data[7]
            }

        return jsonify({"status": True, "message": "Attendance recorded successfully.", "data": data}), 200
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occured: {str(e)}'}),400

@app.route("/update_attendance/<ref_employee_code>", methods = ['PUT'])
def update_attendance(ref_employee_code):
    try:
        data = request.json
        if not data:
            return jsonify({"status": False, "message": "No JSON data provided"}), 400
    
        date = datetime.strptime(data.get('date'), '%Y-%m-%d').date()
        check_in = data.get('check_in')
        check_out = data.get('check_out')
        shift = data.get('shift')
        
        cursor = mysql.connection.cursor()
        cursor.execute("""
                SELECT COUNT(*) FROM attendance_management 
                WHERE ref_employee_code = %s AND date = %s AND status = 'Leave'
            """, (ref_employee_code, date))
        record_count = cursor.fetchone()[0]
    
        if record_count > 0:
            return jsonify({"status": False, "message": "Employee is on leave."}), 400
            
        cursor.callproc('retrieve_attendance_data',(ref_employee_code,date))
        attend_data = cursor.fetchone()
        
        # Existing file names
        existing_attendance = attend_data[7] 
        if shift is None:
            shift=existing_attendance
        
        cursor = mysql.connection.cursor()
        if check_in and not check_out:
        # If only check-in is provided, update check-in and set check-out to null
            check_in_time = datetime.strptime(check_in, '%H:%M').time()
            cursor.execute("""
                UPDATE attendance_management 
                SET check_in = %s, check_out = NULL, working_hours = NULL, status = 'Present', shift = %s
                WHERE ref_employee_code = %s AND date = %s
            """, (check_in, shift, ref_employee_code, date))
        elif check_in and check_out:
            # If both check-in and check-out are provided, update both and calculate working hours
            check_in_time = datetime.strptime(check_in, '%H:%M').time()
            check_out_time = datetime.strptime(check_out, '%H:%M').time()
    
            # Determine if the shift spans midnight
            if check_out_time < check_in_time:
                # Check_out time is earlier than check_in time, so we add 24 hours to check_out time
                check_out_datetime = datetime.combine(date, check_out_time) + timedelta(days=1)
                check_in_datetime = datetime.combine(date, check_in_time)
                working_hours_seconds = (check_out_datetime - check_in_datetime).total_seconds()
            else:
                # Calculate time difference directly if check_out time is later than check_in time
                check_out_datetime = datetime.combine(date, check_out_time)
                check_in_datetime = datetime.combine(date, check_in_time)
                working_hours_seconds = (check_out_datetime - check_in_datetime).total_seconds()
    
            # Convert seconds to time format
            working_hours = str(timedelta(seconds=working_hours_seconds))
            cursor.execute("""
                UPDATE attendance_management 
                SET check_in = %s, check_out = %s, working_hours = %s, status = 'Present', shift = %s
                WHERE ref_employee_code = %s AND date = %s
            """, (check_in, check_out, working_hours, shift, ref_employee_code, date))
        elif check_out and not check_in:
            # If only check-out is provided, this logic can be expanded similarly
            return jsonify({"status": False, "message": "Check-in time is required when updating check-out"}), 400
        else:
            # If neither check-in nor check-out are provided, handle other cases like absent status
            cursor.execute("""
                UPDATE attendance_management 
                SET status = 'Absent', check_in = NULL, check_out = NULL, working_hours = NULL, shift = %s
                WHERE ref_employee_code = %s AND date = %s
            """, (shift, ref_employee_code, date))
        mysql.connection.commit()
        
        cursor.callproc('retrieve_attendance_data',(ref_employee_code,date))
        attend_data = cursor.fetchone()
        cursor.close()
        data = {'date': attend_data[2].strftime("%d-%m-%Y"),
                "check_in": attend_data[3],
                'check_out': attend_data[4],
                'ref_employee_code': attend_data[1],
                'working_hours': attend_data[5],
                'shift':attend_data[7]}
        return jsonify({"status":True,"message":"Attendance updated successfully.","data":data}), 200
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occured: {str(e)}'}),400

@app.route('/delete_attendance/<id>',methods=["DELETE"])
def delete_attendance(id):
    # employee_id = request.args.get('employee_id')
    cursor = mysql.connection.cursor()
    cursor.execute("select * from attendance_management where id = %s",(id,))
    user = cursor.fetchone()
    
    if not user:
        return jsonify({"status":False,"message":"Form validation error","error":"Employee ID not found."}), 200
    
    cursor.execute('UPDATE attendance_management set is_active = 0 where id = %s',(id,))
    mysql.connection.commit()
    cursor.close()
    
    return jsonify({"status":True,
                    "message":"Attendance deleted successfully",
                    "data": id}), 200
    
def save_to_database(df):
    try:
        required_columns = ['ref_employee_code', 'date', 'check_in', 'check_out', 'working_hours', 'status', 'shift']
        
        # Check if all required columns are present
        for column in required_columns:
            if column not in df.columns:
                return False, f"Field missing: {column}"
        # connection = mysql.connector.connect(**mysql_config)
        cursor = mysql.connection.cursor()

        for _, row in df.iterrows():
            # employee_code = row['id']
            ref_employee_code = row['ref_employee_code']
            date = row['date']
            check_in = row['check_in']
            check_out = row['check_out']
            working_hours = row['working_hours']
            status = row['status']
            shift = row['shift']
            
            cursor.execute("""
                SELECT COUNT(*) FROM attendance_management 
                WHERE ref_employee_code = %s AND date = %s
            """, (ref_employee_code, date))
            record_count = cursor.fetchone()[0]

            # If the row does not exist, insert it into the database
            if record_count == 0:
                cursor.callproc("insert_attendance_management", (ref_employee_code, date, check_in, check_out, working_hours, status, shift))

        mysql.connection.commit()
        cursor.close()
        # connection.close()
        return True, None
    except Exception as e:
        return False, str(e)

@app.route('/upload_excel', methods=['POST'])
def upload_excel():
    if 'file' not in request.files:
        return jsonify({"status": False, "message": "No file part"}), 200

    file = request.files['file']

    if file.filename == '':
        return jsonify({"status": False, "message": "No selected file"}), 200

    if file:
        try:
            # Check file extension
            file_extension = file.filename.rsplit('.', 1)[1].lower()

            if file_extension == 'xlsx':
                # Read Excel file into pandas DataFrame
                df = pd.read_excel(file, engine='openpyxl')
            elif file_extension == 'csv':
                # Read CSV file into pandas DataFrame
                df = pd.read_csv(file, delimiter=',')
                if 'date' in df.columns:
                    df['date'] = pd.to_datetime(df['date'], format='%d-%m-%Y').dt.strftime('%Y-%m-%d')
            else:
                return jsonify({"status": False, "message": "Unsupported file format"}), 200

            # Save data to MySQL database
            success, message = save_to_database(df)
            if success:
                return jsonify({"status": True, "message": "Data uploaded and saved to the database"}), 200
            else:
                return jsonify({"status": False, "message": f"{message}."}), 500
        except Exception as e:
            return jsonify({"status": False, "message": str(e)}), 500

    return jsonify({"status": False, "message": "File upload failed"}), 200

@app.route('/attendance_management_total/<ref_employee_code>/<year>/<month>', methods=['GET'])
def calculate_total_attendance(ref_employee_code, year, month):

    # Convert year and month to integer
    year = int(year)
    month = int(month)

    # Get the number of days in the given month and year
    num_days_in_month = calendar.monthrange(year, month)[1]

    # Initialize counters for total days excluding weekends and for each shift
    total_days_excluding_weekends = 0
    regular_shift_days = 0
    morning_shift_days = 0
    afternoon_shift_days = 0
    night_shift_days = 0

    # Loop through each day in the month
    for day in range(1, num_days_in_month + 1):
        # Get the day of the week (0: Monday, 1: Tuesday, ..., 6: Sunday)
        day_of_week = calendar.weekday(year, month, day)
        # Exclude Saturday (5) and Sunday (6)
        if day_of_week not in (5, 6):
            total_days_excluding_weekends += 1

    # Retrieve all attendance records for the specified employee, month, and shift
    cursor = mysql.connection.cursor()
    cursor.callproc('calculate_total_attendance', (ref_employee_code, year, month))
    
    attendance_records = cursor.fetchall()
    cursor.close()

    # Initialize counters for present and absent days, and shifts worked
    present_days = 0
    absent_days = 0

    # Loop through attendance records
    for record in attendance_records:
        status, shift = record
        
        # Count the number of present and absent days
        if status == 'Present':
            present_days += 1
        elif status == 'Absent':
            absent_days += 1
        
        # Count the number of days worked in each shift
        if status == 'Present':
            if shift == 'regular_shift':
                regular_shift_days += 1
            elif shift == 'morning_shift':
                morning_shift_days += 1
            elif shift == 'afternoon_shift':
                afternoon_shift_days += 1
            elif shift == 'night_shift':
                night_shift_days += 1

    # Calculate the number of allowed paid leave days (maximum of 2)
    paid_leave_days = min(2, absent_days)

    # Calculate the total days the employee was present (including paid leave days)
    total_present_days = present_days + paid_leave_days

    # Calculate the total attendance percentage
    total_attendance_percentage = (total_present_days / total_days_excluding_weekends) * 100

    # Return the result as a JSON response
    return jsonify({
        "status": True,
        "message": f"Total attendance for employee {ref_employee_code} in {calendar.month_name[month]} {year}",
        "total_working_days": total_days_excluding_weekends,
        "present_days": present_days,
        "absent_days": absent_days,
        "total_paid_days": total_present_days,
        "total_attendance_percentage": total_attendance_percentage,
        "regular_shift_days": regular_shift_days,
        "morning_shift_days": morning_shift_days,
        "afternoon_shift_days": afternoon_shift_days,
        "night_shift_days": night_shift_days
    }), 200
    
@app.route('/attendance_management_by_emp/<employee_code>', methods=['GET'])
def attendance_management_emp(employee_code):
    total_records = request.args.get('total_records', type=int)
    per_page = request.args.get('per_page',default=10,type=int)
    
    if total_records is None:
        cursor = mysql.connection.cursor()
        cursor.execute("""select count(*) from attendance_management where is_active = 1 and ref_employee_code = %s""",
                       (employee_code,))
        total_records = cursor.fetchone()[0]
        
    total_pages = total_records // per_page
    if total_records % per_page != 0 :
        total_pages += 1
    
    page = request.args.get('page', default=1, type=int)
    
    if page > total_pages :
        return jsonify({'status':False,'message':'Page not found.','data':[]}),200
    
    offset = (page - 1) * per_page 
    
    if page == total_pages and total_records % per_page !=0:
        per_page = total_records % per_page   
        
    cursor = mysql.connection.cursor()
    cursor.callproc('getattendancepaginationbyemp',[employee_code,per_page,offset])
    user = cursor.fetchall()
    cursor.close()
    
    atd_list = []
    for atd in user:
        atd_dict={
            "ref_employee_code" : atd[0],
            "date" : atd[1].strftime('%d-%m-%Y'),
            "check_in" : atd[2],
            "check_out" : atd[3],
            "working_hours" : atd[4],
            "status": atd[5],
            "id":atd[6],
            "shift":atd[7],
            'full_name':atd[8]
        }
        atd_list.append(atd_dict)
    return jsonify({"status":True,"message":f"Attendance list","data":atd_list,'page':page,'per_page':per_page,
                    'total_records':total_records,'total_pages':total_pages})
############################################# ATTENDANCE ENDS HERE ################################################

UPLOAD_FOLDER_leave = r"/home/fi2e8gs31z4n/projecthrms/leave_doc"
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}

app.config['UPLOAD_FOLDER_leave'] = UPLOAD_FOLDER_leave
########################################## leave management starts here ########################################################

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/apply_leave', methods=['POST'])
def apply_leave():
    try:
        ref_employee_code = request.form.get('ref_employee_code')
        leave_type = request.form.get('leave_type')
        start_date = datetime.strptime(request.form.get('start_date'), '%Y-%m-%d').date()
        end_date = datetime.strptime(request.form.get('end_date'), '%Y-%m-%d').date()
        reason = request.form.get('reason')
        leave_document = request.files.get('leave_document')

        # Check if the start date is a Sunday
        if start_date.weekday() == 6:  # Sunday is represented by 6
            return jsonify({'success': False, 'message': 'Cannot apply for leave starting on a Sunday', 'data': {}}), 200

        # Retrieve employee details from personal_information table for display
        cursor = mysql.connection.cursor()
        cursor.execute("""
            SELECT full_name, department, role FROM personal_information 
            WHERE employee_code = %s
        """, (ref_employee_code,))
        employee_data = cursor.fetchone()

        if not employee_data:
            cursor.close()
            return jsonify({'success': False, 'message': 'Employee not found', 'data': {}}), 400

        full_name, department, role = employee_data

        # Check if the employee has already taken leave on the same date in the same month and year
        cursor.execute("""
            SELECT COUNT(*) 
            FROM leave_management 
            WHERE 
                ref_employee_code = %s 
                AND DATE(start_date) = %s
                AND MONTH(start_date) = MONTH(%s) 
                AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
        """, (ref_employee_code, start_date, start_date, start_date))
        leave_count_same_day = cursor.fetchone()[0]

        if leave_count_same_day > 0:
            cursor.close()
            return jsonify({'success': False, 'message': 'Employee has already taken leave on this date.', 'data': {}}), 400

        # Check if the employee has already applied for both sick leave and unpaid leave
        if leave_type != 'paid_leave':
            cursor.execute("""
                SELECT COUNT(*) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type IN ('sick_leave', 'unpaid_leave')
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, start_date, start_date))
            total_leave_types = cursor.fetchone()[0]

            if total_leave_types >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee has already applied for both leaves in this month. Employee can only apply for paid leave.', 'data': {}}), 400

        # Check if the employee is trying to apply for unpaid leave after taking two days of sick leave
        if leave_type == 'unpaid_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'sick_leave' 
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, start_date, start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            if total_sick_leave_days >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take unpaid leave after taking two days of sick leave in the same month.', 'data': {}}), 400

        if leave_type == 'sick_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'unpaid_leave' 
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, start_date, start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            if total_sick_leave_days >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take sick leave after taking two days of unpaid leave in the same month.', 'data': {}}), 400

        # Check the total number of sick leave days taken by the employee in the same month
        if leave_type == 'sick_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'sick_leave'
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, start_date, start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            # Calculate the duration of the current sick leave application
            current_leave_duration = (end_date - start_date).days + 1

            if total_sick_leave_days + current_leave_duration > 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take more than two sick leaves in a month.', 'data': {}}), 400

            # Check if the employee is taking two consecutive sick leave days and no leave document is provided
            if current_leave_duration == 2 and not leave_document:
                cursor.close()
                return jsonify({'success': False, 'message': 'Leave document is required for two consecutive sick leave days', 'data': {}}), 400

        if leave_type in ['unpaid_leave', 'sick_leave']:
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type IN ('sick_leave', 'unpaid_leave') 
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, start_date, start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0
            # Calculate the duration of the current unpaid leave application
            current_leave_duration = (end_date - start_date).days + 1

            if total_sick_leave_days == 1 and current_leave_duration >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee has already taken 1 day free leave in this month. Employee can only opt for 1 day leave.', 'data': {}}), 400

        if leave_type == 'unpaid_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'unpaid_leave'
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, start_date, start_date))
            total_unpaid_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            # Calculate the duration of the current sick leave application
            current_leave_duration = (end_date - start_date).days + 1

            if total_unpaid_leave_days + current_leave_duration > 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take more than two unpaid leaves in a month.', 'data': {}}), 400

        if leave_type in ['maternity_leave', 'paternity_leave']:
            # Check if leave document is provided
            if not leave_document:
                return jsonify({'success': False, 'message': 'Leave document is required for maternity and paternity leave applications', 'data': {}}), 400

        # Function to save uploaded files
        def save_file(file, filename_prefix):
            if file and allowed_file(file.filename):
                file_extension = os.path.splitext(file.filename)[1]
                filename = f"{ref_employee_code}_{filename_prefix}{file_extension}"
                file.save(os.path.join(app.config['UPLOAD_FOLDER_leave'], filename))
                return filename
            return None

        # Save the leave document if provided
        leave_document_filename = save_file(leave_document, 'leave_document')

        # Call the stored procedure to insert the leave application
        cursor.callproc('InsertLeaveApplication', (ref_employee_code, leave_type, start_date, end_date, reason, leave_document_filename))
        mysql.connection.commit()
        cursor.close()

        # Construct the data to be included in the response
        response_data = {
            'ref_employee_code': ref_employee_code,
            'full_name': full_name,
            'department': department,
            'role': role,
            'leave_type': leave_type,
            'start_date': str(start_date),
            'end_date': str(end_date),
            'reason': reason,
            'leave_document': leave_document_filename
        }

        return jsonify({'success': True, 'message': 'Leave application submitted successfully', 'data': response_data}), 201

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
    
@app.route('/all_leave_applications', methods=['GET'])
def get_all_leave_applications():
    try:
        cursor = mysql.connection.cursor()

        # Call the stored procedure to retrieve all leave applications
        cursor.callproc("GetAllLeaveApplications")

        # Fetch all results
        leave_applications = cursor.fetchall()

        leave_applications_data = []
        for leave_application in leave_applications:
            ref_employee_code, leave_type, start_date, end_date, reason, leave_document, created_at, full_name, department, role = leave_application

            # Construct URL for leave document if it exists
            leave_document_url = None
            if leave_document:
                leave_document_url = url_for('uploaded_file', filename=leave_document, _external=True)

            # Format dates as date, month, year
            start_date_str = start_date.strftime("%d-%m-%Y") if start_date else None
            end_date_str = end_date.strftime("%d-%m-%Y") if end_date else None
           
            leave_applications_data.append({
                'ref_employee_code': ref_employee_code,
                'leave_type': leave_type,
                'start_date': start_date_str,
                'end_date': end_date_str,
                'reason': reason,
                'leave_document': leave_document_url,
                'full_name': full_name,
                'department': department,
                'role': role
            })

        cursor.close()

        return jsonify({'success': True, 'message': 'All leave applications retrieved successfully', 'data': leave_applications_data}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
    
@app.route('/pending_leaves', methods=['GET'])
def pending_leaves():
    try:
        # Get total records and per_page from request, or calculate total_records if not provided
        total_records = request.args.get('total_records', type=int)
        per_page = request.args.get('per_page', default=10, type=int)
        
        if total_records is None:
            cursor = mysql.connection.cursor()
            cursor.execute("SELECT COUNT(*) FROM leave_management WHERE status = 'pending' AND is_active = 1")
            total_records = cursor.fetchone()[0]
            cursor.close()
            
        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1
            
        # Get the current page from request, default is 1
        page = request.args.get('page', default=1, type=int)
        
        if page > total_pages:
            return jsonify({"success": False, "message": 'Page not found.', "data": []}), 200
        
        offset = (page - 1) * per_page
        
        # Prepare to call the stored procedure with pagination parameters
        cursor = mysql.connection.cursor()
        cursor.callproc('GetPendingLeaves', (per_page, offset))
        leave_requests = cursor.fetchall()
        cursor.close()
        
        leave_requests_data = []
        for leave_request in leave_requests:
            id, ref_employee_code, full_name, role, department, leave_type, start_date, end_date, reason, status = leave_request
            
            # Format dates as date, month, year
            start_date_str = start_date.strftime("%d-%m-%Y") if start_date else None
            end_date_str = end_date.strftime("%d-%m-%Y") if end_date else None
            
            leave_requests_data.append({
                'id': id,
                'ref_employee_code': ref_employee_code,
                'full_name': full_name,
                'role': role,
                'department': department,
                'leave_type': leave_type,
                'start_date': start_date_str,
                'end_date': end_date_str,
                'reason': reason,
                'status': status
            })
        
        return jsonify({
            'success': True,
            'message': 'Pending leave requests retrieved successfully',
            'page': page,
            'per_page': per_page,
            'total_records': total_records,
            'total_pages': total_pages,
            'data': leave_requests_data
        }), 200
    
    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/reject_leaves', methods=['GET'])
def reject_leaves():
    try:
        cursor = mysql.connection.cursor()

        # Retrieve leave requests with status 'Rejected'
        cursor.execute("""
            SELECT 
                lm.ref_employee_code, pi.full_name, pi.role, pi.department, lm.start_date, lm.end_date, lm.reason, lm.status
            FROM 
                leave_management lm
            INNER JOIN 
                personal_information pi ON lm.ref_employee_code = pi.employee_code
            WHERE 
                lm.status = 'Rejected' AND lm.is_active = 1
        """)
        leave_requests = cursor.fetchall()

        leave_requests_data = []
        for leave_request in leave_requests:
            ref_employee_code, full_name, role, department, start_date, end_date, reason, status = leave_request
            leave_requests_data.append({
                'ref_employee_code': ref_employee_code,
                'full_name': full_name,
                'role': role,
                'department': department,
                'start_date': str(start_date),
                'end_date': str(end_date),
                'reason': reason,
                'status': status
            })

        # Check if there are rejected leave requests
        if not leave_requests_data:
            return jsonify({'success': True, 'message': 'No rejected leave requests', 'data': []}), 200

        return jsonify({'success': True, 'message': 'Leave requests retrieved successfully', 'data': leave_requests_data}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/leave_management/<int:leave_request_id>', methods=['POST'])
def manage_leave(leave_request_id):
    try:
        cursor = mysql.connection.cursor()

        if request.method == 'POST':
            data = request.json
            action = data.get('action')

            # Check if the action is valid
            if action not in ['approve', 'reject']:
                return jsonify({'success': False, 'message': 'Invalid action', 'data': {}}), 400

            cursor.execute("""
                SELECT  
                    ref_employee_code, status, start_date, end_date, leave_type
                FROM 
                    leave_management
                WHERE 
                    id = %s
            """, (leave_request_id,))
            leave_request = cursor.fetchone()

            if not leave_request:
                return jsonify({'success': False, 'message': 'Leave request not found', 'data': {}}), 400

            ref_employee_code, leave_status, start_date, end_date, leave_type = leave_request

            # If the leave was previously rejected, it should remain rejected
            if leave_status == 'Rejected':
                return jsonify({'success': False, 'message': 'Leave request cannot be modified after rejection', 'data': {}}), 400

            # Otherwise, update leave status based on action
            if action == 'approve':
                # Check if the leave request has already been approved
                if leave_status == 'Approved':
                    return jsonify({'success': True, 'message': 'Leave request already approved', 'data': {}}), 400

                cursor.execute("UPDATE leave_management SET status = 'Approved' WHERE id = %s", (leave_request_id,))
                
                # Iterate through each date between start_date and end_date
                current_date = start_date
                while current_date <= end_date:
                    # Check if entry already exists for this date
                    cursor.execute("SELECT COUNT(*) FROM attendance_management WHERE ref_employee_code = %s AND date = %s", (ref_employee_code, current_date))
                    record_count = cursor.fetchone()[0]
                    
                    if record_count == 0:
                        # Insert absent entry for this date
                        cursor.execute("INSERT INTO attendance_management (ref_employee_code, date, status) VALUES (%s, %s, 'leave')", (ref_employee_code, current_date))
                    
                    # Move to the next date
                    current_date += timedelta(days=1)

                # If the leave type is compensatory_leave or paid_leave, update the respective leave type in the leaves_information table
                if leave_type in ['compensatory_leave', 'paid_leave']:
                    column_name = 'compensatory_leave' if leave_type == 'compensatory_leave' else 'paid_leave'
                    cursor.execute(f"SELECT {column_name} FROM leaves_information WHERE ref_employee_code = %s", (ref_employee_code,))
                    current_leave_row = cursor.fetchone()
                    
                    current_leave = current_leave_row[0] if current_leave_row and current_leave_row[0] is not None else 0
                    
                    leave_days = (end_date - start_date).days + 1
                    
                    if current_leave_row:
                        cursor.execute(f"UPDATE leaves_information SET {column_name} = %s WHERE ref_employee_code = %s", (current_leave + leave_days, ref_employee_code))
                    else:
                        cursor.execute(f"INSERT INTO leaves_information (ref_employee_code, {column_name}) VALUES (%s, %s)", (ref_employee_code, leave_days))

                    mysql.connection.commit()

                    response_data = {
                        'ref_employee_code': ref_employee_code,
                        'status': action.capitalize(),
                        column_name: current_leave + leave_days
                    }

                    return jsonify({'success': True, 'message': f'Leave request {action}ed successfully', 'data': response_data}), 400
                else:
                    cursor.execute("SELECT sick_leave, unpaid_leave, marriage_leave, maternity_leave, paternity_leave, bereavement_leave FROM ms_total_leaves where is_active = 1 ORDER BY id DESC LIMIT 1")
                    leave_limits = cursor.fetchone()

                    if leave_limits:
                        leave_limits_mapping = {
                            'sick_leave': leave_limits[0],
                            'paid_leave': 0,
                            'unpaid_leave': leave_limits[1],
                            'marriage_leave': leave_limits[2],
                            'maternity_leave': leave_limits[3],
                            'paternity_leave': leave_limits[4],
                            'bereavement_leave': leave_limits[5],
                            'compensatory_leave': 0
                        }

                        leave_counts = {leave_type: 0 for leave_type in leave_limits_mapping}
                        taken_leave_days = {leave_type: 0 for leave_type in leave_limits_mapping}

                        cursor.execute("""
                            SELECT 
                                leave_type,
                                start_date,
                                end_date
                            FROM 
                                leave_management
                            WHERE 
                                ref_employee_code = %s AND status = 'Approved'
                        """, (ref_employee_code,))
                        leave_info = cursor.fetchall()

                        if leave_info:
                            consecutive_leave_start_date = None

                            for leave_entry in leave_info:
                                leave_type = leave_entry[0]
                                start_date = leave_entry[1]
                                end_date = leave_entry[2]
                                leave_duration = (end_date - start_date).days + 1

                                if leave_type == 'sick_leave' or (leave_type == 'unpaid_leave' and leave_duration > 1):
                                    current_date = start_date
                                    while current_date <= end_date:
                                        if consecutive_leave_start_date is None:
                                            consecutive_leave_start_date = current_date
                                        if consecutive_leave_start_date == current_date:
                                            taken_leave_days['sick_leave'] += 1
                                        elif consecutive_leave_start_date + timedelta(days=1) == current_date:
                                            taken_leave_days['unpaid_leave'] += 1
                                        else:
                                            taken_leave_days['marriage_leave' or 'maternity_leave' or 'paternity_leave' or 'bereavement_leave'] += 1
                                        current_date += timedelta(days=1)
                                    consecutive_leave_start_date = None
                                else:
                                    taken_leave_days[leave_type] += leave_duration

                            remaining_leave = {
                                leave_type: max(leave_limits_mapping[leave_type] - taken_leave_days[leave_type], 0)
                                for leave_type in leave_limits_mapping
                            }

                            cursor.execute("SELECT COUNT(*) FROM leaves_information WHERE ref_employee_code = %s", (ref_employee_code,))
                            row_count = cursor.fetchone()[0]

                            if row_count == 0:
                                cursor.execute("""
                                    INSERT INTO leaves_information 
                                    (ref_employee_code, sick_leave, remaining_sick_leave, unpaid_leave, remaining_unpaid_leave, marriage_leave, remaining_marriage_leave, maternity_leave, remaining_maternity_leave, paternity_leave, remaining_paternity_leave, bereavement_leave, remaining_bereavement_leave)
                                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                                """, (
                                    ref_employee_code,
                                    leave_limits_mapping['sick_leave'],
                                    remaining_leave['sick_leave'],
                                    leave_limits_mapping['unpaid_leave'],
                                    remaining_leave['unpaid_leave'],
                                    leave_limits_mapping['marriage_leave'],
                                    remaining_leave['marriage_leave'],
                                    leave_limits_mapping['maternity_leave'],
                                    remaining_leave['maternity_leave'],
                                    leave_limits_mapping['paternity_leave'],
                                    remaining_leave['paternity_leave'],
                                    leave_limits_mapping['bereavement_leave'],
                                    remaining_leave['bereavement_leave']
                                ))
                            else:
                                cursor.execute("""
                                    UPDATE leaves_information 
                                    SET 
                                        sick_leave = %s,
                                        remaining_sick_leave = %s,
                                        unpaid_leave = %s,
                                        remaining_unpaid_leave = %s,
                                        marriage_leave = %s,
                                        remaining_marriage_leave = %s,
                                        maternity_leave = %s,
                                        remaining_maternity_leave = %s,
                                        paternity_leave = %s,
                                        remaining_paternity_leave = %s,
                                        bereavement_leave = %s,
                                        remaining_bereavement_leave = %s
                                    WHERE ref_employee_code = %s
                                """, (
                                    leave_limits_mapping['sick_leave'],
                                    remaining_leave['sick_leave'],
                                    leave_limits_mapping['unpaid_leave'],
                                    remaining_leave['unpaid_leave'],
                                    leave_limits_mapping['marriage_leave'],
                                    remaining_leave['marriage_leave'],
                                    leave_limits_mapping['maternity_leave'],
                                    remaining_leave['maternity_leave'],
                                    leave_limits_mapping['paternity_leave'],
                                    remaining_leave['paternity_leave'],
                                    leave_limits_mapping['bereavement_leave'],
                                    remaining_leave['bereavement_leave'],
                                    ref_employee_code
                                ))

                            mysql.connection.commit()

                            response_data = {
                                'ref_employee_code': ref_employee_code,
                                'status': action.capitalize(),
                                'leave_limits': {
                                    'sick_leave': leave_limits_mapping['sick_leave'],
                                    'unpaid_leave': leave_limits_mapping['unpaid_leave'],
                                    'marriage_leave': leave_limits_mapping['marriage_leave'],
                                    'maternity_leave': leave_limits_mapping['maternity_leave'],
                                    'paternity_leave': leave_limits_mapping['paternity_leave'],
                                    'bereavement_leave': leave_limits_mapping['bereavement_leave']
                                },
                                'leave_info': {
                                    'sick_leave': {
                                        'total': leave_limits_mapping['sick_leave'],
                                        'taken': taken_leave_days['sick_leave'],
                                        'remaining': remaining_leave['sick_leave']
                                    },
                                    'unpaid_leave': {
                                        'total': leave_limits_mapping['unpaid_leave'],
                                        'taken': taken_leave_days['unpaid_leave'],
                                        'remaining': remaining_leave['unpaid_leave']
                                    },
                                    'marriage_leave': {
                                        'total': leave_limits_mapping['marriage_leave'],
                                        'taken': taken_leave_days['marriage_leave'],
                                        'remaining': remaining_leave['marriage_leave']
                                    },
                                    'maternity_leave': {
                                        'total': leave_limits_mapping['maternity_leave'],
                                        'taken': taken_leave_days['maternity_leave'],
                                        'remaining': remaining_leave['maternity_leave']
                                    },
                                    'paternity_leave': {
                                        'total': leave_limits_mapping['paternity_leave'],
                                        'taken': taken_leave_days['paternity_leave'],
                                        'remaining': remaining_leave['paternity_leave']
                                    },
                                    'bereavement_leave': {
                                        'total': leave_limits_mapping['bereavement_leave'],
                                        'taken': taken_leave_days['bereavement_leave'],
                                        'remaining': remaining_leave['bereavement_leave']
                                    },
                                }
                            }

                            return jsonify({'success': True, 'message': f'Leave request {action}ed successfully', 'data': response_data}), 200
            else:  # action == 'reject'
                cursor.execute("UPDATE leave_management SET status = 'Rejected' WHERE id = %s", (leave_request_id,))

                mysql.connection.commit()
                cursor.close()

                response_data = {
                    
                    'ref_employee_code': ref_employee_code,
                    'status': action.capitalize()
                }

                return jsonify({'success': True, 'message': f'Leave request {action}ed successfully', 'data': response_data}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/update_leave/<int:ref_employee_code>/<string:start_date>', methods=['PUT'])
def update_leave(ref_employee_code, start_date):
    try:
        # Extracting fields from the request data
        leave_type = request.form.get('leave_type')
        new_start_date_str = request.form.get('start_date')
        new_end_date_str = request.form.get('end_date')
        reason = request.form.get('reason')
        leave_document = request.files.get('leave_document')

        # Parse dates if not None
        new_start_date = datetime.strptime(new_start_date_str, '%Y-%m-%d').date() if new_start_date_str else None
        end_date = datetime.strptime(new_end_date_str, '%Y-%m-%d').date() if new_end_date_str else None
        cursor = mysql.connection.cursor()  
        # Retrieve status and existing leave document of the leave application
        cursor.execute("""
            SELECT 
                status, leave_document 
            FROM 
                leave_management 
            WHERE 
                ref_employee_code = %s and start_date = %s
        """, (ref_employee_code, start_date))
        leave_data = cursor.fetchone()

        # Ensure leave application exists
        if not leave_data:
            cursor.close()
            return jsonify({'success': False, 'message': 'Leave application not found for the employee', 'data': {}}), 400

        status, existing_leave_document = leave_data
        if new_start_date and new_start_date.weekday() == 6:  # Sunday is represented by 6
            cursor.close()
            return jsonify({'success': False, 'message': 'Cannot update leave to start on a Sunday', 'data': {}}), 400

        # Check if the employee has already taken leave on the same date in the same month and year
        cursor.execute("""
            SELECT COUNT(*) 
            FROM leave_management 
            WHERE 
                ref_employee_code = %s 
                AND DATE(start_date) = %s
                AND MONTH(start_date) = MONTH(%s) 
                AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
        """, (ref_employee_code, new_start_date, new_start_date, start_date))
        leave_count_same_day = cursor.fetchone()[0]

        if leave_count_same_day > 0:
            cursor.close()
            return jsonify({'success': False, 'message': 'Employee has already taken leave on this date.', 'data': {}}), 400

        # Check if the employee has already applied for both sick leave and unpaid leave
        if leave_type != 'paid_leave':
            cursor.execute("""
                SELECT COUNT(*) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type IN ("sick_leave", "unpaid_leave")
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, new_start_date, new_start_date))
            total_leave_types = cursor.fetchone()[0]

            if total_leave_types >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee has already applied for both leaves in this month. Employee can only apply for paid leave.', 'data': {}}), 400

        # Check if the employee is trying to apply for unpaid leave after taking two days of sick leave
        if leave_type == 'unpaid_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'sick_leave' 
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, new_start_date, new_start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            if total_sick_leave_days >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take unpaid leave after taking two days of sick leave in the same month.', 'data': {}}), 400

        # Check if the employee is trying to apply for maternity_leave or paternity_leave without a leave_document
        if leave_type == 'maternity_leave' or leave_type == 'paternity_leave':
            if not leave_document:
                cursor.close()
                return jsonify({'success': False, 'message': 'Leave document is required for maternity/paternity leave', 'data': {}}), 400

        if leave_type == 'sick_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'unpaid_leave' 
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, new_start_date, new_start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            if total_sick_leave_days >= 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take sick leave after taking two days of unpaid leave in the same month.', 'data': {}}), 400

        # Check the total number of sick leave days taken by the employee in the same month
        if leave_type == 'sick_leave':
            cursor.execute("""
                SELECT SUM(DATEDIFF(end_date, start_date) + 1) 
                FROM leave_management 
                WHERE 
                    ref_employee_code = %s 
                    AND leave_type = 'sick_leave'
                    AND MONTH(start_date) = MONTH(%s) 
                    AND YEAR(start_date) = YEAR(%s) and status = 'Approved'
            """, (ref_employee_code, new_start_date, new_start_date))
            total_sick_leave_days = cursor.fetchone()[0] or 0  # if no sick leave found, consider total as 0

            # Calculate the duration of the current sick leave application
            current_leave_duration = (end_date - new_start_date).days + 1

            if total_sick_leave_days + current_leave_duration > 2:
                cursor.close()
                return jsonify({'success': False, 'message': 'Employee cannot take more than two sick leaves in a month.', 'data': {}}), 400

            # Check if the employee is taking two consecutive sick leave days and no leave document is provided
            if current_leave_duration == 2 and not leave_document:
                cursor.close()
                return jsonify({'success': False, 'message': 'Leave document is required for two consecutive sick leave days', 'data': {}}), 400

        # Function to save uploaded files
        def save_file(file, filename_prefix, existing_file=None):
            if file and allowed_file(file.filename):
                file_extension = os.path.splitext(file.filename)[1]
                filename = f"{ref_employee_code}_{filename_prefix}{file_extension}"
                file.save(os.path.join(app.config['UPLOAD_FOLDERLeave'], filename))
                return filename
            return existing_file

        # Save the leave document if provided
        leave_document_filename = save_file(leave_document, 'leave_document', existing_leave_document)
        
        # Check if the leave application is already approved or rejected
        if status == 'Pending':
            # Update leave application using stored procedure
            cursor.callproc('UpdateLeaveStatusByEmployeeAndDate', (
                ref_employee_code, start_date, leave_type, new_start_date, end_date, reason, status, leave_document_filename
            ))
            mysql.connection.commit()
            cursor.close()

            # Construct updated leave application data for response
            updated_leave_application_data = {
                'ref_employee_code': ref_employee_code,
                'leave_type': leave_type,
                'start_date': str(new_start_date),
                'end_date': str(end_date),
                'reason': reason,
                'status': status,
                'leave_document': leave_document_filename
            }

            return jsonify({'success': True, 'message': 'Leave application updated successfully', 'data': updated_leave_application_data}), 200
        else:
            cursor.close()
            return jsonify({'success': False, 'message': 'Cannot update leave application that is already approved or rejected', 'data': {}}), 400

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
        
@app.route('/delete_apply_leave/<int:id>', methods=["DELETE"])
def delete_apply_leave(id):
    try:
        cursor = mysql.connection.cursor()

        # Call the stored procedure
        cursor.callproc('DeleteLeaveApplication', [id, '@p_message'])

        # Retrieve the output message
        cursor.execute('SELECT @p_message')
        result = cursor.fetchone()

        if result is None:
            message = "No message returned from stored procedure."
        elif result[0] is None:
            message = "employee deactivate."
        else:
            message = result[0]

        mysql.connection.commit()
        cursor.close()

        if message and "not found" in message.lower():
            return jsonify({"status": False, "message": message}), 404
        else:
            return jsonify({"status": True, "message": message, "data": id}), 200
    except Exception as e:
        return jsonify({"status": False, "message": str(e)}), 500
    
@app.route('/ms_leaves', methods=['POST'])
def ms_leaves():
    try:
        data = request.json
        
        # Extract data from the request
        sick_leave = data.get('sick_leave')
        unpaid_leave = data.get('unpaid_leave')
        marriage_leave = data.get('marriage_leave')
        maternity_leave = data.get('maternity_leave')
        paternity_leave = data.get('paternity_leave')
        bereavement_leave = data.get('bereavement_leave')
        date = data.get('date')  # Assuming 'date' is in the correct date format
        
        is_active = 1

        # Validate input data
        if None in [sick_leave, unpaid_leave, marriage_leave, maternity_leave, paternity_leave, bereavement_leave, date]:
            return jsonify({'success': False, 'message': 'Missing required fields in the request'}), 200

        cursor = mysql.connection.cursor()

        # Check if entry for the date already exists
        cursor.execute("SELECT * FROM ms_total_leaves WHERE date = %s", (date,))
        existing_entry = cursor.fetchone()

        if existing_entry:
            # If entry exists, return message indicating duplicate entry
            return jsonify({'success': False, 'message': 'Data for this date already exists and cannot be updated'}), 200
        else:
            # Call stored procedure to insert new entry
            cursor.callproc('InsertTotalLeaves', 
                [sick_leave, unpaid_leave, marriage_leave, maternity_leave, paternity_leave, bereavement_leave, date, is_active])
            mysql.connection.commit()
            cursor.close()
            return jsonify({'success': True, 'message': 'Leaves inserted successfully'}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/get_active_ms_leaves', methods=['GET'])
def get_active_ms_leaves():
    try:
        # Pagination parameters
        per_page = request.args.get('per_page', default=10, type=int)
        page = request.args.get('page', default=1, type=int)

        cursor = mysql.connection.cursor()

        # Fetch the total number of active records
        cursor.execute("SELECT COUNT(*) FROM ms_total_leaves WHERE is_active = 1")
        total_records = cursor.fetchone()[0]

        # Calculate the total number of pages
        total_pages = (total_records + per_page - 1) // per_page  # Equivalent to math.ceil(total_records / per_page)

        # If the page is greater than the total pages, return empty data
        if page > total_pages:
            return jsonify({'status': False, 'message': 'Page not found', 'data': []}), 200

        # Calculate the offset
        offset = (page - 1) * per_page

        # Call the stored procedure
        cursor.callproc('GetActiveLeavesWithPagination', (per_page, offset))
        
        # Fetch results from the stored procedure
        records = cursor.fetchall()
        cursor.close()

        # Convert the records to a list of dictionaries
        leaves_list = []
        for record in records:
            leave_dict = {
                'id': record[0],
                'sick_leave': record[1],
                'unpaid_leave': record[2],
                'marriage_leave': record[3],
                'maternity_leave': record[4],
                'paternity_leave': record[5],
                'bereavement_leave': record[6],
                'date': record[7],  # already formatted as '%d-%m-%Y' in stored procedure
                'is_active': record[8]
            }
            leaves_list.append(leave_dict)

        return jsonify({
            "status": True,
            "message": "Displaying paginated data",
            "page": page,
            "per_page": per_page,
            "total_records": total_records,
            "total_pages": total_pages,
            "data": leaves_list
        }), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


@app.route('/update_ms_leaves/<int:id>', methods=['PUT'])
def update_ms_leaves(id):
    try:
        data = request.json

        # Extract data from the request
        sick_leave = data.get('sick_leave')
        unpaid_leave = data.get('unpaid_leave')
        marriage_leave = data.get('marriage_leave')
        maternity_leave = data.get('maternity_leave')
        paternity_leave = data.get('paternity_leave')
        bereavement_leave = data.get('bereavement_leave')
        date = data.get('date')  # Assuming 'year' is in the correct date format

        # Validate input data
        if None in [sick_leave, unpaid_leave, marriage_leave, maternity_leave, paternity_leave, bereavement_leave, date]:
            return jsonify({'success': False, 'message': 'Missing required fields in the request'}), 200

        # Update the data using the stored procedure
        cursor = mysql.connection.cursor()
        cursor.callproc('UpdateMSLeavesByID', (id, sick_leave, unpaid_leave, marriage_leave, maternity_leave, paternity_leave, bereavement_leave, date))
        mysql.connection.commit()
        cursor.close()

        return jsonify({'success': True, 'message': 'Leaves updated successfully'}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

@app.route('/get_ms_leaves/<leave_id>', methods=['GET'])
def get_ms_leaves(leave_id):
    try:
        cursor = mysql.connection.cursor()
        cursor.callproc('GetMSLeavesByID', (leave_id,))
        record = cursor.fetchone()
        cursor.close()

        if record:
            # Convert the record to a dictionary
            leave_dict = {
                'id': record[0],
                'sick_leave': record[1],
                'unpaid_leave': record[2],
                'marriage_leave': record[3],
                'maternity_leave': record[4],
                'paternity_leave': record[5],
                'bereavement_leave': record[6],
                'date': record[7],
                'is_active': record[8]
            }

            return jsonify({'success': True, 'data': leave_dict}), 200
        else:
            return jsonify({'success': False, 'message': 'No active record found with the specified ID'}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


@app.route('/delete_ms_leaves/<int:id>', methods=["DELETE"])
def delete_ms_leaves(id):
    try:
        cursor = mysql.connection.cursor()

        # Call the stored procedure
        cursor.callproc('DeleteMsLeaves', [id, '@p_message'])

        # Retrieve the output message
        cursor.execute('SELECT @p_message')
        result = cursor.fetchone()
        message = result[0]

        mysql.connection.commit()
        cursor.close()

        if "not found" in message.lower():
            return jsonify({"status": False, "message": message}), 404
        else:
            return jsonify({"status": True, "message": message, "data": id}), 200
    except Exception as e:
        return jsonify({"status": False, "message": str(e)}), 500


@app.route('/employee_leave_count/<ref_employee_code>', methods=['GET'])
def employee_leave_count(ref_employee_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.callproc('GetEmployeeLeaveCount', (ref_employee_code,))
        records = cursor.fetchone()
        cursor.close()

        if records:
            response_data = {
                'sick_leave': records[2],
                'remaining_sick_leave': records[3], 
                'paid_leave': records[4],
                'unpaid_leave': records[5],
                'remaining_unpaid_leave': records[6],
                'marriage_leave': records[7],
                'remaining_marriage_leave': records[8],
                'maternity_leave': records[9],
                'remaining_maternity_leave': records[10],
                'paternity_leave': records[11],
                'remaining_paternity_leave': records[12],
                'bereavement_leave': records[13],
                'remaining_bereavement_leave': records[14],
                'compensatory_leave': records[15]
            }

            return jsonify({'success': True, 'data': response_data}), 200
        else:
            return jsonify({'success': False, 'message': 'No active records found'}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

#######################################leave_report#######################################

    
@app.route('/count_approved_leave_today', methods=['GET'])
def count_approved_leave_today():
    try:
        # Get today's date
        today = datetime.now().date()

        cursor = mysql.connection.cursor()

        # Call the stored procedure
        cursor.callproc('GetApprovedLeaveCountToday', (today,))

        # Fetch the result from the stored procedure
        approved_leave_count_today = cursor.fetchone()[0]
        cursor.close()

        return jsonify({'success': True, 'message': 'Approved leave applications count for today retrieved successfully', 'data': {'approved_leave_count_today': approved_leave_count_today}}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
    
@app.route('/leave_application/<int:id>', methods=['GET'])
def get_leave_application(id):
    try:
        cursor = mysql.connection.cursor()

        # Call the stored procedure
        cursor.callproc('GetLeaveApplicationById', [id])

        # Fetch the result set from the stored procedure
        leave_application = cursor.fetchone()
        cursor.close()

        if leave_application:
            ref_employee_code, leave_type, start_date, end_date, reason, created_at, full_name, department, role = leave_application
            leave_application_data = {
                'ref_employee_code': ref_employee_code,
                'leave_type': leave_type,
                'start_date': str(start_date),
                'end_date': str(end_date),
                'reason': reason,
                'created_at': str(created_at),
                'full_name': full_name,
                'department': department,
                'role': role
            }
            return jsonify({'success': True, 'message': 'Leave application retrieved successfully', 'data': leave_application_data}), 200
        else:
            return jsonify({'success': False, 'message': 'Leave application not found'}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

@app.route('/leave_edit/<int:ref_employee_code>', methods=['GET'])
def leave_edit(ref_employee_code):
    try:
        per_page = request.args.get('per_page', default=10, type=int)
        page = request.args.get('page', default=1, type=int)

        cursor = mysql.connection.cursor()

        # Define variables to store output parameters
        p_total_records = 0
        p_total_pages = 0

        # Call the stored procedure and pass placeholders for output parameters
        cursor.callproc("GetLeaveApplicationsByEmployeeCode", (ref_employee_code, per_page, page, p_total_records, p_total_pages))

        # Fetch the results of the stored procedure
        leave_applications = cursor.fetchall()

        # Fetch the output parameters
        cursor.execute("SELECT @p_total_records, @p_total_pages")
        output_params = cursor.fetchone()
        p_total_records = output_params[0]
        p_total_pages = output_params[1]

        cursor.close()

        # Format the fetched data
        leave_applications_data = []
        for leave_application in leave_applications:
            id, ref_employee_code,leave_type, start_date, end_date, reason, status = leave_application

            # Format dates as date, month, year
            start_date_str = start_date.strftime("%d-%m-%Y") if start_date else None
            end_date_str = end_date.strftime("%d-%m-%Y") if end_date else None

            leave_applications_data.append({
                'id': id,
                'ref_employee_code':ref_employee_code,
                'leave_type': leave_type,
                'start_date': start_date_str,
                'end_date': end_date_str,
                'reason': reason,
                'status': status
            })

        return jsonify({
            'status': True,
            'message': f'Displaying leave applications for employee code {ref_employee_code}.',
            'data': leave_applications_data,
            'page': page,
            'per_page': per_page,
            'total_records': p_total_records,
            'total_pages': p_total_pages
        }), 200

    except Exception as e:
        print("Error occurred:", e)
        print(traceback.format_exc())
        return jsonify({'status': False, 'message': f'An error occurred: {str(e)}'}), 500

@app.route('/holidays', methods=['GET'])
def get_indian_holidays():
    api_key = "hhDxXuq7vnZpgrCjOptIpq9WjxCs4zd9"
    current_year = datetime.now().year
    url = f'https://calendarific.com/api/v2/holidays?api_key={api_key}&country=IN&year={current_year}'

    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        holidays = data['response']['holidays']

        # List of specific holidays to include
        specific_holidays = [
            "Makar Sankranti",
            "Republic Day",
            "Maha Shivaratri/Shivaratri",
            "Good Friday",
            "Ugadi",
            "International Worker's Day",
            "Independence Day",
            "Ganesh Chaturthi/Vinayaka Chaturthi",
            "Mahatma Gandhi Jayanti",
            "Maha Ashtami",
            "Dussehra",
            "Diwali/Deepavali",
            "Christmas"
        ]

        # Filter and format holidays
        filtered_holidays = []
        for holiday in holidays:
            if holiday['name'] in specific_holidays:
                date_str = holiday['date']['iso']
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                formatted_date = date_obj.strftime('%d-%m-%Y')
                filtered_holidays.append({
                    'name': holiday['name'],
                    'date': formatted_date
                })

        # Manually add "Kannada Rajyotsava" if it is not in the API response
        kannada_rajyotsava_date = f"01-11-{current_year}"  # Dynamically set the date to November 1st of the current year
        if not any(holiday['name'] == "Kannada Rajyotsava" for holiday in filtered_holidays):
            filtered_holidays.append({
                'name': "Kannada Rajyotsava",
                'date': kannada_rajyotsava_date
            })

        # Sort holidays by date
        filtered_holidays.sort(key=lambda x: datetime.strptime(x['date'], '%d-%m-%Y'))

        return jsonify({'year': current_year, 'holidays': filtered_holidays})
    else:
        return jsonify({'error': f'Failed to fetch Indian holidays for year {current_year}'}), 500


@app.route("/leave_calendar/<ref_employee_code>",methods=["GET"])
def leave_calendar(ref_employee_code):
    try:
       # Change this to the desired year
        current_year = datetime.now().year
        holidays_response = requests.get(f"https://canteencard.in/projecthrms/holidays")
        if holidays_response.status_code != 200:
            return jsonify({'status': False, 'message': f'Failed to fetch holidays for {current_year}.'}), 500
        holidays_data = holidays_response.json()
        holidays = holidays_data.get('holidays', [])

        # Fetching leave details (assuming you're using MySQL)
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT ref_employee_code, start_date, end_date, leave_type from leave_management where ref_employee_code = %s and status = 'Approved'",
                       (ref_employee_code,))
        leave_calendar = cursor.fetchall()
        cursor.close()
        
        dates = []
        for leave in leave_calendar:
            leave_data = {
                'ref_employee_code': leave[0],
                'start_date': leave[1].strftime('%Y-%m-%d'),
                'end_date': leave[2].strftime('%Y-%m-%d'),
                'leave_type':leave[3]
            }
            dates.append(leave_data)
        
        # Combining leave details with holidays
        response_data = {'status': True, 'message': 'Leave details and holidays.', 'data': dates, 'holidays': holidays}
        return jsonify(response_data), 200
    except Exception as e:
        return jsonify({'status': False, 'message': f'An error occurred: {str(e)}.'}), 500  

                  
############################## Leave management ends here #########################################    
 
############################## SALARY SLIP STARTS HERE #######################################

@app.route("/master_shift_allowance", methods=['POST'])
def master_shift_allowance():
    try:
        data = request.json
        morning_shift = data.get('morning_shift')
        afternoon_shift = data.get('afternoon_shift')
        night_shift = data.get('night_shift')
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from master_shift_allowance where YEAR(curdate()) = year(created_at) and is_active = 1")
        master_shift = cursor.fetchone()
        
        if master_shift:
            return jsonify({'status':False,'message':'Allowance already created for this year.'})
        
        cursor.execute("insert into master_shift_allowance (morning_shift, afternoon_shift, night_shift) values (%s,%s,%s)",(morning_shift,afternoon_shift,night_shift))
        mysql.connection.commit()
        
        cursor.execute("select * from master_shift_allowance order by id desc limit 1")
        shift = cursor.fetchone()
        cursor.close()
        
        if shift:
            data = {"id":shift[0],
                    "morning_shift":shift[1],
                    "afternoon_shift":shift[2],
                    "night_shift":shift[3]}
            
        return jsonify({"status":True,"message":'Shift allowances added successfully.',"data":data})
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occured: {str(e)}.'})
    
@app.route("/update_master_shift_allowance/<id>", methods=['PUT'])
def update_master_shift_allowance(id):
    try:
        data = request.json
        morning_shift = data.get('morning_shift')
        afternoon_shift = data.get('afternoon_shift')
        night_shift = data.get('night_shift')
        
        cursor = mysql.connection.cursor()
        cursor.execute("""update master_shift_allowance set morning_shift = %s, afternoon_shift = %s, night_shift = %s where id = %s """,
                       (morning_shift,afternoon_shift,night_shift,id))
        mysql.connection.commit()
        
        cursor.execute("select * from master_shift_allowance where id = %s",(id,))
        shift = cursor.fetchone()
        cursor.close()
        
        if shift:
            data = {"id":shift[0],
                    "morning_shift":shift[1],
                    "afternoon_shift":shift[2],
                    "night_shift":shift[3]}
            
        return jsonify({"status":True,"message":'Shift allowances updated successfully.',"data":data})
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occured: {str(e)}.'})
    
@app.route("/delete_allowance/<id>",methods = ['DELETE'])
def delete_allowance(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("update master_shift_allowance set is_active = 0 where id = %s",(id,))
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({'status':True,'message':'Allowance deleted successfully.','data':id})
    except Exception as e:
        return jsonify({'status':False,'message':f'Error occured: {str(e)}.'})
    
@app.route("/shift_allowance_list",methods = ['GET'])
def shift_allowance_list():
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("Select * from master_shift_allowance where is_active = 1")
        allowance = cursor.fetchall()
        cursor.close()
        
        shift = []
        for list in allowance:
            data = {"id":list[0],
                    "morning_shift":list[1],
                    "afternoon_shift":list[2],
                    "night_shift":list[3],
                    "date":list[5].strftime('%d-%m-%Y')
                    }
            shift.append(data)
            
        return jsonify({'status':True,'message':'displaying data.','data':shift})
    except Exception as e :
        return jsonify({'status':False,'message':f'Error occurred: {str(e)}.'})
    
@app.route("/prefill_update_shift_allowance/<id>",methods = ['GET'])
def prefill_update_shift_allowance(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("Select * from master_shift_allowance where is_active = 1 and id = %s",(id,))
        allowance = cursor.fetchone()
        cursor.close()
        
        if allowance:
            data = {"id":allowance[0],
                    "morning_shift":allowance[1],
                    "afternoon_shift":allowance[2],
                    "night_shift":allowance[3]}
            
        return jsonify({'status':True,'message':'displaying data.','data':data})
    except Exception as e :
        return jsonify({'status':False,'message':f'Error occurred: {str(e)}.'})
        
@app.route("/master_payroll_insert", methods=['POST'])
def master_payroll():
    try:
        data = request.json
        da = data.get('da')
        hra_metro = data.get('hra_metro')
        hra_non_metro = data.get('hra_non_metro')
        std_deduction_new_reg = data.get('std_deduction_new_reg')
        std_deduction_old_reg = data.get('std_deduction_old_reg')
        
        # Check if payroll for the current year already exists and is active
        cursor = mysql.connection.cursor()
        cursor.execute("""
            SELECT * FROM master_payroll 
            WHERE YEAR(curdate()) = YEAR(created_at) 
            AND is_active = 1
        """)
        payroll = cursor.fetchone()
        cursor.close()
        
        if payroll:
            return jsonify({'status': False, 'message': 'Allowance already created for this year.'}), 400
        
        # Insert new payroll entry
        cursor = mysql.connection.cursor()
        cursor.execute("""
            INSERT INTO master_payroll (da, hra_metro, hra_non_metro,std_deduction_new_reg,std_deduction_old_reg) 
            VALUES (%s, %s, %s, %s, %s)
        """, (da, hra_metro, hra_non_metro,std_deduction_new_reg,std_deduction_old_reg))
        mysql.connection.commit()
        
        # Fetch the latest inserted payroll entry
        cursor.execute('SELECT * FROM master_payroll ORDER BY id DESC LIMIT 1')
        payroll_fetch = cursor.fetchone()
        cursor.close()
        
        if payroll_fetch:
            new_list = {
                'id': payroll_fetch[0],
                'da': payroll_fetch[1],
                'hra_metro': payroll_fetch[2],
                'hra_non_metro': payroll_fetch[3],
                'std_deduction_new_reg': payroll_fetch[4],
                'std_deduction_old_reg': payroll_fetch[5]
            }
            return jsonify({'status': True, 'message': 'Allowances created successfully.', 'data': new_list}), 200
    
    except Exception as e:
        return jsonify({'status': False, 'message': 'Error occurred.', 'Error': str(e)}), 500
    
@app.route('/master_payroll_update/<id>',methods=['PUT'])
def master_payroll_update(id):
    try:
        data = request.json
        da = data.get('da')
        hra_metro = data.get('hra_metro')
        hra_non_metro = data.get('hra_non_metro')
        std_deduction_new_reg = data.get('std_deduction_new_reg')
        std_deduction_old_reg = data.get('std_deduction_old_reg')
        
        cursor = mysql.connection.cursor()
        cursor.execute("""Update master_payroll set da=%s, hra_metro=%s, hra_non_metro=%s, std_deduction_new_reg=%s, std_deduction_old_reg=%s
                       where is_active = 1 and id = %s""",(da,hra_metro,hra_non_metro,std_deduction_new_reg,std_deduction_old_reg,id))
        mysql.connection.commit()
        
        cursor.execute('Select * from master_payroll where id=%s',(id))
        payroll_fetch = cursor.fetchone()
        cursor.close()
        
        if payroll_fetch:
            new_list = {
                'id':payroll_fetch[0],
                'da':payroll_fetch[1],
                'hra_metro':payroll_fetch[2],
                'hra_non_metro':payroll_fetch[3],
                'std_deduction_new_reg': payroll_fetch[4],
                'std_deduction_old_reg': payroll_fetch[5]
            }
            return jsonify({"status":True,"message":'Allowance updated successfully.','data':new_list}),200
        
    except Exception as e:
        return jsonify({'status':False,'message':'Error Occured.','error':str(e)}), 500
    
@app.route("/master_payroll_get", methods=['GET'])
def master_payroll_get():
    try:
        cursor = mysql.connection.cursor()
        cursor.execute('Select * from master_payroll where is_active = 1')
        payroll_list = cursor.fetchall()
        cursor.close()
        
        data = []
        for i in payroll_list:
            full_list = {
                'id': i[0],
                'da': i[1],
                'hra_metro': i[2],
                'hra_non_metro': i[3],
                'std_deduction_new_reg': i[4],
                'std_deduction_old_reg': i[5]
            }
            data.append(full_list)
            
        return jsonify({'status':True,'message':'Allowance list.','data':data}),200
    except Exception as e:
        return jsonify({'status':False,'message':'Error occured.','error':str(e)}),500
    
@app.route("/master_payroll_delete/<id>", methods=['DELETE'])
def master_payroll_delete(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute('UPDATE master_payroll set is_active = 0 where id=%s',(id))
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({'status':True,'message':'Allowance deleted successfully.','data':id}),200
    except Exception as e:
        return jsonify({'status':False,'message':'Error occured.','error':str(e)}),500
    
@app.route("/master_payroll_prefill/<id>", methods = ["GET"])
def master_payroll_prefill(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("select * from master_payroll where id = %s",(id))
        prefill = cursor.fetchone()
        cursor.close()
        
        if prefill:
            data = {"id":prefill[0],
                    'da': prefill[1],
                'hra_metro': prefill[2],
                'hra_non_metro': prefill[3],
                'std_deduction_new_reg': prefill[4],
                'std_deduction_old_reg': prefill[5]
            }
            
            return jsonify({"status":True,"message":'Data retrieved successfully.', "data":data}),200
            
    except Exception as e : 
        return jsonify({'status':False,'message':'Error occured.','error':str(e)}),500
    
@app.route('/tax_slab_insert', methods = ["POST"])
def tax_slab_insert():
    try:
        data = request.json
        regime = data.get('regime')
        slabs = data.get('slabs')
        
        if not isinstance(slabs, list):
            return jsonify({'error': 'Slabs must be a list'}), 400
        
        cursor = mysql.connection.cursor()
        # Insert each slab
        for slab in slabs:
            lower_limit = slab.get('lower_limit')
            upper_limit = slab.get('upper_limit')
            tax_rate = slab.get('tax_rate')
            
            if regime.lower() == 'old_regime':
                if upper_limit is None:
                    cursor.execute("insert into old_tax_slab(lower_limit, upper_limit, tax_rate) values (%s,null,%s)",
                           (lower_limit,tax_rate))
                else:
                    cursor.execute("insert into old_tax_slab(lower_limit, upper_limit, tax_rate) values (%s,%s,%s)",
                           (lower_limit,upper_limit,tax_rate))
            else:
                if upper_limit is None:
                    cursor.execute("insert into new_tax_slab(lower_limit, upper_limit, tax_rate) values (%s,null,%s)",
                           (lower_limit,tax_rate))
                else:
                    cursor.execute("insert into new_tax_slab(lower_limit, upper_limit, tax_rate) values (%s,%s,%s)",
                           (lower_limit,upper_limit,tax_rate))
                
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({'status':True,'message':'Tax slabs inserted successfully.', 'data':slabs}),200
    except Exception as e:
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500

@app.route('/tax_slab_update', methods = ["PUT"])
def tax_slab_update():
    try:
        data = request.json
        regime = data.get('regime')
        slabs = data.get('slabs')
        
        if not isinstance(slabs, list):
            return jsonify({'error': 'Slabs must be a list'}), 400
        
        cursor = mysql.connection.cursor()
        # Insert each slab
        for slab in slabs:
            slab_id = slab.get('id') 
            lower_limit = slab.get('lower_limit')
            upper_limit = slab.get('upper_limit')
            tax_rate = slab.get('tax_rate')
            
            if slab_id is None:
                return jsonify({'error': 'Slab ID is required for updating'}), 400
            
            if regime.lower() == 'old_regime':
                if upper_limit is None:
                    cursor.execute("""UPDATE old_tax_slab 
                               SET lower_limit = %s, upper_limit = NULL, tax_rate = %s 
                               WHERE id = %s""",
                           (lower_limit, tax_rate, slab_id))
                else:
                    cursor.execute("""UPDATE old_tax_slab 
                               SET lower_limit = %s, upper_limit = %s, tax_rate = %s 
                               WHERE id = %s""",
                           (lower_limit,upper_limit,tax_rate,slab_id))
            elif regime.lower() == 'new_regime':
                if upper_limit is None:
                    cursor.execute("""UPDATE new_tax_slab 
                               SET lower_limit = %s, upper_limit = NULL, tax_rate = %s 
                               WHERE id = %s""",
                           (lower_limit, tax_rate, slab_id))
                else:
                    cursor.execute("""UPDATE new_tax_slab 
                               SET lower_limit = %s, upper_limit = %s, tax_rate = %s 
                               WHERE id = %s""",
                           (lower_limit,upper_limit,tax_rate,slab_id))
            else:
                return jsonify({'error': 'Invalid regime type. Must be "old_regime" or "new_regime".'}), 400
                
        mysql.connection.commit()
        cursor.close()
        return jsonify({'status':True,'message':'Tax slabs updated successfully.', 'data':slabs}),200
    except Exception as e:
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500
    
@app.route('/tax_slab_list', methods = ['GET'])
def tax_slab_list():
    try:
        regime = request.args.get('regime')
        
        cursor = mysql.connection.cursor()
        if regime.lower() == 'old_regime':
            cursor.execute('select * from old_tax_slab where is_active = 1')
        else:
            cursor.execute('select * from new_tax_slab where is_active = 1')
        tax_slab = cursor.fetchall()
        cursor.close()
        slabs = []
        for i in tax_slab:
            list = {'id':i[0],
                    'lower_limit':i[1],
                    'upper_limit':i[2],
                    'tax_rate':i[3]}
            slabs.append(list)
            
        return jsonify({'status':True,'message':'Tax slab list.','data':slabs}),200
            
    except Exception as e :
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500
    
@app.route("/tax_slab_delete", methods = ['DELETE'])
def tax_slab_delete():
    try:
        data = request.json
        id = data.get("id")
        regime = data.get("regime")
        cursor = mysql.connection.cursor()
        
        if regime == "old_regime":
            cursor.execute("update old_tax_slab set is_active = 0 where id = %s", (id,))
        else:
            cursor.execute("update new_tax_slab set is_active = 0 where id = %s", (id,))
            
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({"status":True,"message":'Tax slab deleted successfully.',"data":{'id':id,'regime':regime}}),200    
    except Exception as e:
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500
        
@app.route("/tax_slab_prefill", methods=['GET'])
def tax_slab_prefill():
    try:
        # Get query parameters from the request
        id = request.args.get("id")
        regime = request.args.get("regime")

        cursor = mysql.connection.cursor()

        if regime == 'old_regime':
            cursor.execute("select * from old_tax_slab where id = %s", (id,))
        else:
            cursor.execute("select * from new_tax_slab where id = %s", (id,))

        prefil = cursor.fetchone()

        if prefil:
            return jsonify({
                "status": True,
                "message": 'Data fetched successfully.',
                "data": {
                    'id': prefil[0],
                    'lower_limit': prefil[1],
                    'upper_limit': prefil[2],
                    'tax_rate': prefil[3]
                }
            })
        else:
            return jsonify({"status": False, "message": "No data found for the given ID."}), 404

    except Exception as e:
        return jsonify({"status": False, "message": 'Error Occurred.', "Error": str(e)}), 500


UPLOAD_FOLDER_tax = r"/home/fi2e8gs31z4n/projecthrms/tax_doc"
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}

app.config['UPLOAD_FOLDER_tax'] = UPLOAD_FOLDER_tax

@app.route("/regime_insert", methods = ['POST'])
def regime_insert():
    try:
        ref_employee_code = request.form.get('ref_employee_code')
        regime = request.form.get("regime")
        house_rent = request.form.get('house_rent', None)  # Optional, defaults to None
        house_doc = request.files.get('house_doc',None)  # Optional, defaults to None
        insurance = request.form.get('insurance', None)  # Optional, defaults to None
        insurance_doc = request.files.get('insurance_doc',None)  # Optional, defaults to None
        
        house_rent_doc_filename = None
        if house_doc and allowed_file(house_doc.filename):
            # Save house rent document with filename format employee_code_house_rent.extension
            house_rent_doc_extension = os.path.splitext(house_doc.filename)[1]  # Get file extension
            house_rent_doc_filename = f"{ref_employee_code}_house_rent{house_rent_doc_extension}"
            house_rent_doc_path = os.path.join(app.config['UPLOAD_FOLDER_tax'], house_rent_doc_filename)
            house_doc.save(house_rent_doc_path)

        insurance_doc_filename = None
        if insurance_doc and allowed_file(insurance_doc.filename):
            # Save insurance document with filename format employee_code_insurance.extension
            insurance_doc_extension = os.path.splitext(insurance_doc.filename)[1]  # Get file extension
            insurance_doc_filename = f"{ref_employee_code}_insurance{insurance_doc_extension}"
            insurance_doc_path = os.path.join(app.config['UPLOAD_FOLDER_tax'], insurance_doc_filename)
            insurance_doc.save(insurance_doc_path)

        # Ensure required fields are provided
        if not ref_employee_code or not regime:
            return jsonify({"status": False, "message": "Employee code and tax regime are required."}), 400
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where ref_employee_code = %s and is_active = 1",(ref_employee_code,))
        emp_code = cursor.fetchone()
        
        if emp_code:
            return jsonify({'status':False, "message":"Employee has already selected the tax regime."}),400

        cursor.execute("""insert into payroll_regime (ref_employee_code,tax_regime,house_rent,house_rent_doc,insurance,insurance_doc) values 
                       (%s,%s,%s,%s,%s,%s)""",(ref_employee_code,regime,house_rent,house_rent_doc_filename,insurance,insurance_doc_filename))
        mysql.connection.commit()
        cursor.close()
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where ref_employee_code = %s",(ref_employee_code,))
        selection = cursor.fetchone()
        cursor.close()
        
        if selection :
            data = {'id':selection[0],
                    'ref_employee_code':selection[1],
                    'regime':selection[2],
                    'house_rent':selection[3],
                    'house_doc':selection[4],
                    'insurance':selection[5],
                    'insurance_doc':selection[6]}
            
            return jsonify({'status':True,'message':'Payroll regime inserted successfully.','data':data}),200
    except Exception as e:
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500
    
@app.route("/regime_update/<ref_employee_code>", methods = ['PUT'])
def regime_update(ref_employee_code):
    try:
        regime = request.form.get("regime")
        house_rent = request.form.get('house_rent', None)  # Optional, defaults to None
        house_doc = request.files.get('house_doc',None)  # Optional, defaults to None
        insurance = request.form.get('insurance', None)  # Optional, defaults to None
        insurance_doc = request.files.get('insurance_doc',None)  # Optional, defaults to None
        
        # Ensure required fields are provided
        if not ref_employee_code or not regime:
            return jsonify({"status": False, "message": "Employee code and tax regime are required."}), 400
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where ref_employee_code = %s",(ref_employee_code,))
        user = cursor.fetchone()
        cursor.close()
        
        existing_house_doc = user[4]
        existing_insurance_doc = user[6]
        
        if house_doc and allowed_file(house_doc.filename):
            # Save house rent document with filename format employee_code_house_rent.extension
            house_rent_doc_extension = os.path.splitext(house_doc.filename)[1]  # Get file extension
            house_rent_doc_filename = f"{ref_employee_code}_house_rent{house_rent_doc_extension}"
            house_rent_doc_path = os.path.join(app.config['UPLOAD_FOLDER_tax'], house_rent_doc_filename)
            house_doc.save(house_rent_doc_path)
        else:
            house_rent_doc_filename = existing_house_doc

        if insurance_doc and allowed_file(insurance_doc.filename):
            # Save insurance document with filename format employee_code_insurance.extension
            insurance_doc_extension = os.path.splitext(insurance_doc.filename)[1]  # Get file extension
            insurance_doc_filename = f"{ref_employee_code}_insurance{insurance_doc_extension}"
            insurance_doc_path = os.path.join(app.config['UPLOAD_FOLDER_tax'], insurance_doc_filename)
            insurance_doc.save(insurance_doc_path)
        else:
            insurance_doc_filename = existing_insurance_doc
        
        cursor = mysql.connection.cursor()
        cursor.execute("""Update payroll_regime set tax_regime=%s,house_rent=%s,house_rent_doc=%s,insurance=%s,
                       insurance_doc=%s where ref_employee_code = %s""",
                       (regime,house_rent,house_rent_doc_filename,insurance,insurance_doc_filename,ref_employee_code,))
        mysql.connection.commit()
        cursor.close()
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where ref_employee_code = %s",(ref_employee_code,))
        selection = cursor.fetchone()
        cursor.close()
        
        if selection :
            data = {'id':selection[0],
                    'ref_employee_code':selection[1],
                    'regime':selection[2],
                    'house_rent':selection[3],
                    'house_doc':selection[4],
                    'insurance':selection[5],
                    'insurance_doc':selection[6]}
            
            return jsonify({'status':True,'message':'Payroll regime updated successfully.','data':data}),200
    except Exception as e:
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500        

@app.route("/regime_list", methods=["GET"])
def regime_list():
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where is_active = 1")
        users = cursor.fetchall()
        cursor.close()
        
        user_list = []
        for i in users:
            data = {"id":i[0],
                    'ref_employee_code':i[1],
                    'regime':i[2],
                    'house_rent':i[3],
                    'house_doc':i[4],
                    'insurance':i[5],
                    'insurance_doc':i[6]}
            user_list.append(data)
        return jsonify({"status":True,"message":'List retrieved successfully.',"data":user_list}),200
    except Exception as e :
           return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500
       
@app.route("/emp_regime_list/<ref_employee_code>", methods=["GET"])
def emp_regime_list(ref_employee_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where is_active = 1 and ref_employee_code = %s",(ref_employee_code,))
        users = cursor.fetchone()
        cursor.close()
       
        if users:
            data = {"id":users[0],
                    'ref_employee_code':users[1],
                    'regime':users[2],
                    'house_rent':users[3],
                    'house_doc':users[4],
                    'insurance':users[5],
                    'insurance_doc':users[6]}
            
        return jsonify({"status":True,"message":'List retrieved successfully.',"data":data}),200
    except Exception as e :
           return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500    

@app.route("/regime_delete/<id>", methods = ['DELETE'])
def regime_delete(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("update payroll_regime set is_active = 0 where id = %s", (id,))     
        mysql.connection.commit()
        cursor.close()
        
        cursor = mysql.connection.cursor()
        cursor.execute("select * from payroll_regime where id = %s", (id,))
        fetch_data = cursor.fetchone()
        cursor.close()
        
        return jsonify({"status":True,"message":'Employee selection deleted successfully.',"data":{'id':fetch_data[0],'ref_employee_code':fetch_data[1],'regime':fetch_data[2]}}),200    
    except Exception as e:
        return jsonify({"status":False,"message":'Error Occured.',"Error":str(e)}),500
        
month_name_to_number = {month_name.lower(): str(month_number).zfill(2) for month_number, month_name in enumerate(calendar.month_name) if month_name}
# You can now use month_name_to_number to convert month names to their corresponding zero-padded string representation
@app.route("/payroll_management",methods=['POST'])
def payroll_management():
    if request.method == 'POST':
        try:
            # Extract JSON data from the request
            data = request.json
            ref_employee_code = data.get('ref_employee_code')
            year = data.get('year')
            month_name = data.get('month')

            # Check if month_name is provided and not None
            if month_name is None:
                raise ValueError("Month name is missing in the request")

            # Convert month name to zero-padded string representation
            month = month_name_to_number.get(month_name.lower())
            if month is None:
                raise ValueError("Invalid month name")
            print(month)
            # Make a request to the attendance management endpoint to get total_paid_days
            attendance_endpoint = f"https://canteencard.in/projecthrms/attendance_management_total/{ref_employee_code}/{year}/{month}"
            attendance_response = requests.get(attendance_endpoint)
            attendance_data = attendance_response.json()
            
            if attendance_response.status_code != 200:
                raise ValueError(f"Failed to fetch attendance data: {attendance_data.get('error')}")
            
            total_paid_days = attendance_data.get('total_paid_days', 0)
            total_working_days = attendance_data.get('total_working_days', 0)
            morning_shift_days = attendance_data.get('morning_shift_days', 0)
            regular_shift_days = attendance_data.get('regular_shift_days', 0)
            afternoon_shift_days = attendance_data.get('afternoon_shift_days', 0)
            night_shift_days = attendance_data.get('night_shift_days', 0)

            location = data.get('location')
            ctc = float(data.get('ctc', 0))  # Default value of 0 if ctc is missing
            total_salary = float(data.get('month_salary', 0))  # Default value of 0 if month_salary is missing
            total_salary = ctc / 12  # Calculate month_salary only if ctc is provided
            per_day = float(total_salary / total_working_days)
            # paid_days = float(data.get('paid_days', 0))
            medical_allowance = float(data.get('medical_allowance', 0))
            travel_allowance = float(data.get('travel_allowance',0))
            telephone_allowance = float(data.get('telephone_allowance',0))
            meal_allowance = float(data.get('meal_allowance',0))
            leave_travel_allowance = float(data.get('leave_travel_allowance',0))
            professional_development_allowance = float(data.get('professional_development_allowance',0))
            performance_based_allowance = float(data.get('performance_based_allowance',0))
            public_holiday_allowance = float(data.get('public_holiday_allowance',0))
            # Calculate basic salary from CTC
            basic_salary = float(data.get("basic_salary", 0))
            
            cursor = mysql.connection.cursor()
            cursor.execute("select tax_regime, house_rent, insurance from payroll_regime where ref_employee_code = %s",(ref_employee_code,))
            user = cursor.fetchone()
            cursor.close()
            
            # Check if user data is fetched successfully
            if user is None:
                raise ValueError("Payroll regime data not found for the given employee code")

            insurance = float(user[2]) if user[2] is not None else 0  # Handle None value
            tax_regime = user[0]
            
            cursor = mysql.connection.cursor()
            cursor.execute("select morning_shift, afternoon_shift, night_shift from master_shift_allowance where year(created_at) = %s and is_active = 1",(year,))
            shift = cursor.fetchone()
            
            morning_shift_allowance = morning_shift_days * shift[0]
            afternoon_shift_allowance = afternoon_shift_days * shift[1]
            night_shift_allowance = night_shift_days * shift[2]
            shift_allowance = morning_shift_allowance + afternoon_shift_allowance + night_shift_allowance

            # Check if required fields are missing
            if None in (ref_employee_code, location):
                raise ValueError("Required JSON field(s) are missing")
            
            cursor = mysql.connection.cursor()
            cursor.execute("select * from payroll_management where ref_employee_code = %s and year=%s and month=%s and is_active = 1",
                           (ref_employee_code, year, month))
            payroll_id = cursor.fetchone()
            
            if payroll_id:
                return jsonify({"status":False,"message":f"Salary slip of {ref_employee_code} for {calendar.month_name[int(month)]} is already created."})

            # Fetch data from the database based on employee_id
            cursor.execute("SELECT full_name, department, role FROM personal_information WHERE employee_code=%s",
                           (ref_employee_code,))
            employee_data = cursor.fetchone()
            cursor.close()

            # Check if employee exists
            if not employee_data:
                raise ValueError("Employee with the provided ID does not exist")

            full_name, department, role = employee_data
            
            # Calculate DA
            cursor = mysql.connection.cursor()
            cursor.execute("select * from master_payroll where YEAR(curdate()) = year(created_at) and is_active = 1")
            payroll = cursor.fetchone()
            cursor.close()

            DA = round(basic_salary * (payroll[1]/100))
            if location.lower() == "metro":
                HRA = (basic_salary + DA) * (payroll[2]/100)  
            else:
                HRA = (basic_salary + DA) * (payroll[3]/100)
            
            # calculate special allowance
            special_allowance = total_salary - (basic_salary + DA + HRA + medical_allowance + telephone_allowance + travel_allowance)

            # Calculate Gross Salary
            gross_salary = round((per_day * total_paid_days + shift_allowance + meal_allowance + leave_travel_allowance + professional_development_allowance
                               + performance_based_allowance + public_holiday_allowance ),2)
            
            # Total allowance
            total_allowance = (DA + HRA + medical_allowance + special_allowance + telephone_allowance + shift_allowance + 
                               meal_allowance + leave_travel_allowance + professional_development_allowance
                               + performance_based_allowance + public_holiday_allowance + travel_allowance)

            if total_salary > 25000:
                professional_tax = 200
            else:
                professional_tax = 0
                        
            # Calculate PF (Provident Fund) contribution
            pf_employee = round(0.12 * basic_salary)  # Employee's PF contribution
            pf_employer = round(0.12 * basic_salary)  # Employer's PF contribution
            pf_total = pf_employee + pf_employer
            
            # Calculate TDS
            cursor = mysql.connection.cursor()
            # Old tax regime
            if tax_regime == 'old_regime':
                cursor.execute("select * from old_tax_slab where is_active = 1 order by lower_limit")
                tax_slabs = cursor.fetchall()

                std_deduction_old = payroll[5]
                actual_hra_received = HRA * 12
                rent_paid = user[1] * 12  # Assuming rent paid is not provided, otherwise calculate it
                hra_exemption = min(actual_hra_received, 0.5 * basic_salary * 12, max(0, rent_paid - 0.1 * basic_salary * 12))

                total_deductions_old = std_deduction_old + pf_employee * 12 + professional_tax * 12 + hra_exemption + (insurance or 0) * 12
                old_taxable_income = max(gross_salary * 12 - total_deductions_old, 0)

                # print(f"Old Regime Taxable Income: {old_taxable_income}")

                tax_amount = 0
                for slab in tax_slabs:
                    lower_limit = slab[1] if slab[1] is not None else 0
                    upper_limit = slab[2] if slab[2] is not None else float('inf')
                    tax_rate = slab[3] if slab[3] is not None else 0

                    if old_taxable_income > lower_limit:
                        taxable_at_this_slab = min(old_taxable_income, upper_limit) - lower_limit
                        tax_amount += taxable_at_this_slab * tax_rate / 100

                if old_taxable_income <= 500000:
                    rebate_amt_old = 12500
                    tax_amount = max(tax_amount - rebate_amt_old, 0)

                # print(f"Old Regime Tax Amount: {tax_amount}")

            else:
                cursor.execute("select * from new_tax_slab where is_active = 1 order by lower_limit")
                tax_slabs = cursor.fetchall()

                std_deduction_new = payroll[4]
                new_taxable_income = max(ctc - std_deduction_new, 0)

                # print(f"New Regime Taxable Income: {new_taxable_income}")

                tax_amount = 0
                for slab in tax_slabs:
                    lower_limit = slab[1] if slab[1] is not None else 0
                    upper_limit = slab[2] if slab[2] is not None else float('inf')
                    tax_rate = slab[3] if slab[3] is not None else 0

                    if new_taxable_income > lower_limit:
                        taxable_at_this_slab = min(new_taxable_income, upper_limit) - lower_limit
                        tax_amount += taxable_at_this_slab * tax_rate / 100

                if new_taxable_income <= 700000:
                    rebate_amt_new = 25000
                    tax_amount = max(tax_amount - rebate_amt_new, 0)

                # print(f"New Regime Tax Amount: {tax_amount}")

            # Add 4% cess to the calculated tax amount
            cess = tax_amount * 0.04
            tax_amount += cess 
            # Monthly TDS calculation
            tds = round((tax_amount / 12),2)

            # Calculate total deduction (Sum of professional tax, HRA, and DA)
            total_deduction = pf_total + professional_tax + tds + insurance

            # Calculate net salary
            net_salary = gross_salary - total_deduction
            if net_salary < 0:
                net_salary = 0
            # else:
                
            status = 1

            # Insert or update data in the database
            cursor = mysql.connection.cursor()
            cursor.callproc('insert_into_payroll_management', (ref_employee_code,  ctc, medical_allowance, gross_salary, basic_salary, HRA, DA, 
                  professional_tax, pf_total, total_deduction, tds, net_salary,total_allowance,status,special_allowance,
                  total_paid_days,year,month,location,public_holiday_allowance,shift_allowance,meal_allowance,
                  leave_travel_allowance,professional_development_allowance,performance_based_allowance,travel_allowance,
                  telephone_allowance,tax_regime,insurance))

            mysql.connection.commit()
            # Fetch updated record from the database
            cursor.execute("SELECT * FROM payroll_management WHERE ref_employee_code = %s and year = %s and month = %s", (ref_employee_code, year, month))
            data = cursor.fetchone()
            cursor.close()

            response_data = {
                "success": True,
                "message": f"Salary slip of employee {ref_employee_code} for {calendar.month_name[int(month)]} {year} is generated successfully.",
                "data": {
                    "ref_employee_code": data[1],
                    "full_name": full_name,
                    "department": department,
                    "role": role,
                    "location": data[18],
                    "ctc": round(data[12], 2),
                    "medical_allowance": data[7],
                    "month_salary": round(total_salary, 2),
                    "basic_salary": round(data[4], 2),
                    "da": round(data[5], 2),
                    "hra": round(data[6], 2),
                    "professional_tax": data[10],
                    "pf": round(data[9], 2),
                    "total_deduction": round(data[15], 2),
                    "gross_salary": round(data[17], 2),
                    "total_allowance": round(data[14], 2),
                    "tds": round(data[11], 2),
                    "net_salary": round(data[16], 2),
                    "special_allowance":round(data[8],2),
                    "total_working_days":data[13],
                    "year":data[2],
                    "month":month_name,
                    "working_days_per_month" : total_working_days,
                    "travel_allowance":data[19],
                    "telephone_allowance":data[21],
                    "shift_allowance":data[20],
                    "meal_allowance":data[22],
                    "leave_travel_allowance":data[23],
                    "professional_development_allowance":data[24],
                    "performance_based_allowance":data[25],
                    "public_holiday_allowance":data[26],
                    'insurance':insurance,
                    "tax_regime":tax_regime,
                    # "house_rent":rent_paid
                }
            }

            return jsonify(response_data), 200
        except Exception as e:
            print("Error occurred:", e)
            response_data = {
                "success": False,
                "error": str(e),
                "message": f"Error occurred while generating salary slip:{str(e)}. "
            }
            return jsonify(response_data), 500
    
    # If the request method is not POST, return a 405 Method Not Allowed error
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts POST requests"}), 500

@app.route("/update_payroll_management/<ref_employee_code>",methods=['PUT'])
def update_payroll_management(ref_employee_code):
    if request.method == 'PUT':
        try:
            # Extract JSON data from the request
            data = request.json
            year = data.get('year')
            month_name = data.get('month')

            # Check if month_name is provided and not None
            if month_name is None:
                raise ValueError("Month name is missing in the request")

            # Convert month name to zero-padded string representation
            month = month_name_to_number.get(month_name.lower())
            if month is None:
                raise ValueError("Invalid month name")
            # Make a request to the attendance management endpoint to get total_paid_days
            attendance_endpoint = f"https://canteencard.in/projecthrms/attendance_management_total/{ref_employee_code}/{year}/{month}"
            attendance_response = requests.get(attendance_endpoint)
            if attendance_response.status_code != 200:
                raise ValueError("Failed to fetch attendance data")
            
            attendance_data = attendance_response.json()
            # total_paid_days = attendance_data.get('total_paid_days',0)
            total_working_days = attendance_data.get('total_working_days',0)
            morning_shift_days = attendance_data.get('morning_shift_days',0)
            regular_shift_days = attendance_data.get('regular_shift_days',0)
            afternoon_shift_days = attendance_data.get('afternoon_shift_days',0)
            night_shift_days = attendance_data.get('night_shift_days',0)

            # Extract data from JSON
            location = data.get('location')
            ctc = float(data.get('ctc', 0))  # Default value of 0 if ctc is missing
            total_salary = float(data.get('month_salary', 0))  # Default value of 0 if month_salary is missing
            total_salary = ctc / 12  # Calculate month_salary only if ctc is provided
            per_day = float(total_salary / total_working_days)
            total_paid_days = float(data.get('paid_days', 0))
            medical_allowance = float(data.get('medical_allowance', 0))
            travel_allowance = float(data.get('travel_allowance',0))
            telephone_allowance = float(data.get('telephone_allowance',0))
            meal_allowance = float(data.get('meal_allowance',0))
            leave_travel_allowance = float(data.get('leave_travel_allowance',0))
            professional_development_allowance = float(data.get('professional_development_allowance',0))
            performance_based_allowance = float(data.get('performance_based_allowance',0))
            public_holiday_allowance = float(data.get('public_holiday_allowance',0))
            # Calculate basic salary from CTC
            basic_salary = float(data.get("basic_salary", 0))
            
            cursor = mysql.connection.cursor()
            cursor.execute("select tax_regime, house_rent, insurance from payroll_regime where ref_employee_code = %s",(ref_employee_code,))
            user = cursor.fetchone()
            cursor.close()
            
            insurance = float(user[2])
            tax_regime = user[0]
            
            cursor = mysql.connection.cursor()
            cursor.execute("select morning_shift, afternoon_shift, night_shift from master_shift_allowance where year(created_at) = %s and is_active = 1",(year,))
            shift = cursor.fetchone()
            
            morning_shift_allowance = morning_shift_days * shift[0]
            afternoon_shift_allowance = afternoon_shift_days * shift[1]
            night_shift_allowance = night_shift_days * shift[2]
            shift_allowance = morning_shift_allowance + afternoon_shift_allowance + night_shift_allowance

            # Check if required fields are missing
            if None in (ref_employee_code, location):
                raise ValueError("Required JSON field(s) are missing")
            
            cursor = mysql.connection.cursor()
            cursor.execute("select * from payroll_management where ref_employee_code = %s and year=%s and month=%s",
                           (ref_employee_code, year, month))
            payroll_id = cursor.fetchone()
            
            if not payroll_id:
                return jsonify({"status":False,"message":f"Salary slip of {ref_employee_code} for {calendar.month_name[int(month)]} is not created."}),400

            # Fetch data from the database based on employee_id
            cursor = mysql.connection.cursor()
            cursor.execute("SELECT full_name, department, role FROM personal_information WHERE employee_code = %s",
                           (ref_employee_code,))
            employee_data = cursor.fetchone()
            cursor.close()

            # Check if employee exists
            if not employee_data:
                raise ValueError("Employee with the provided ID does not exist")

            full_name, department, role = employee_data
            
            # Calculate DA
            cursor = mysql.connection.cursor()
            cursor.execute("select * from master_payroll where YEAR(curdate()) = year(created_at) and is_active = 1")
            payroll = cursor.fetchone()
            cursor.close()
            
            DA = round(basic_salary * (payroll[1]/100))
            if location.lower() == "metro":
                HRA = (basic_salary + DA) * (payroll[2]/100)  
            else:
                HRA = (basic_salary + DA) * (payroll[3]/100) 
                           
            # calculate special allowance
            special_allowance = total_salary - (basic_salary + DA + HRA + medical_allowance + telephone_allowance + travel_allowance)

            # Calculate Gross Salary
            gross_salary = round((per_day * total_paid_days + shift_allowance + meal_allowance + leave_travel_allowance + professional_development_allowance
                               + performance_based_allowance + public_holiday_allowance),2)
            
            # Total allowance
            total_allowance = (DA + HRA + medical_allowance + special_allowance + telephone_allowance  + meal_allowance + leave_travel_allowance + professional_development_allowance
                               + performance_based_allowance + public_holiday_allowance + travel_allowance)

            # Calculate professional_tax based on different salary ranges
            if total_salary > 25000:
                professional_tax = 200
            else:
                professional_tax = 0  # Example professional tax amount
            # Calculate PF amount
            pf_employee = round(0.12 * basic_salary)  # Employee's PF contribution
            pf_employer = round(0.12 * basic_salary)  # Employer's PF contribution
            pf_total = pf_employee + pf_employer

            # Calculate TDS
            cursor = mysql.connection.cursor()
            # Old tax regime
            if tax_regime == 'old_regime':
                cursor.execute("select * from old_tax_slab order by lower_limit")
                tax_slabs = cursor.fetchall()

                std_deduction_old = payroll[5]
                actual_hra_received = HRA * 12
                rent_paid = user[1] * 12  # Assuming rent paid is not provided, otherwise calculate it
                hra_exemption = min(actual_hra_received, 0.5 * basic_salary * 12, max(0, rent_paid - 0.1 * basic_salary * 12))

                total_deductions_old = std_deduction_old + pf_employee * 12 + professional_tax * 12 + hra_exemption + (insurance or 0) * 12
                old_taxable_income = max(gross_salary * 12 - total_deductions_old, 0)

                # print(f"Old Regime Taxable Income: {old_taxable_income}")

                tax_amount = 0
                for slab in tax_slabs:
                    lower_limit = slab[1] if slab[1] is not None else 0
                    upper_limit = slab[2] if slab[2] is not None else float('inf')
                    tax_rate = slab[3] if slab[3] is not None else 0

                    if old_taxable_income > lower_limit:
                        taxable_at_this_slab = min(old_taxable_income, upper_limit) - lower_limit
                        tax_amount += taxable_at_this_slab * tax_rate / 100

                if old_taxable_income <= 500000:
                    rebate_amt_old = 12500
                    tax_amount = max(tax_amount - rebate_amt_old, 0)

                # print(f"Old Regime Tax Amount: {tax_amount}")

            else:
                cursor.execute("select * from new_tax_slab order by lower_limit")
                tax_slabs = cursor.fetchall()

                std_deduction_new = payroll[4]
                new_taxable_income = max(ctc - std_deduction_new, 0)

                # print(f"New Regime Taxable Income: {new_taxable_income}")

                tax_amount = 0
                for slab in tax_slabs:
                    lower_limit = slab[1] if slab[1] is not None else 0
                    upper_limit = slab[2] if slab[2] is not None else float('inf')
                    tax_rate = slab[3] if slab[3] is not None else 0

                    if new_taxable_income > lower_limit:
                        taxable_at_this_slab = min(new_taxable_income, upper_limit) - lower_limit
                        tax_amount += taxable_at_this_slab * tax_rate / 100

                if new_taxable_income <= 700000:
                    rebate_amt_new = 25000
                    tax_amount = max(tax_amount - rebate_amt_new, 0)

                # print(f"New Regime Tax Amount: {tax_amount}")

            # Add 4% cess to the calculated tax amount
            cess = tax_amount * 0.04
            tax_amount += cess 
            # Monthly TDS calculation
            tds = round((tax_amount / 12),2)

            # Calculate total deduction (Sum of professional tax, HRA, and DA)
            total_deduction = pf_total + professional_tax + tds + insurance

            # Calculate net salary
            # net_salary = gross_salary - total_deduction
            net_salary = gross_salary - total_deduction
            if net_salary < 0:
                net_salary = 0
            # else:
                
            status = 1

            # update data in the database
            cursor = mysql.connection.cursor()
            cursor.callproc('update_payroll_management', (ctc, medical_allowance, gross_salary, basic_salary, HRA, DA, professional_tax, pf_total, total_deduction, tds, net_salary,total_allowance,status,
                  special_allowance,total_paid_days,location,public_holiday_allowance,shift_allowance,meal_allowance,leave_travel_allowance,professional_development_allowance,
                  performance_based_allowance,travel_allowance,telephone_allowance,ref_employee_code,year,month, tax_regime, insurance))

            mysql.connection.commit()
            # Fetch updated record from the database
            cursor.execute("SELECT * FROM payroll_management WHERE ref_employee_code = %s and year = %s and month = %s", (ref_employee_code, year, month))
            data = cursor.fetchone()
            cursor.close()

            response_data = {
                "success": True,
                "message": f"Salary slip of employee {ref_employee_code} for {calendar.month_name[int(month)]} {year} is updated successfully.",
                "data": {
                    "ref_employee_code": data[1],
                    "full_name": full_name,
                    "department": department,
                    "role": role,
                    "location": data[18],
                    "ctc": round(data[12], 2),
                    "medical_allowance": data[7],
                    "month_salary": round(total_salary, 2),
                    "basic_salary": round(data[4], 2),
                    "da": round(data[5], 2),
                    "hra": round(data[6], 2),
                    "professional_tax": data[10],
                    "pf": round(data[9], 2),
                    "total_deduction": round(data[15], 2),
                    "gross_salary": gross_salary,
                    "total_allowance": round(data[14], 2),
                    "tds": round(data[11], 2),
                    "net_salary": round(data[16], 2),
                    "special_allowance":round(data[8],2),
                    "total_working_days":data[13],
                    "year":data[2],
                    "month":month_name,
                    "working_days_per_month" : total_working_days,
                    "travel_allowance":data[19],
                    "telephone_allowance":data[21],
                    "shift_allowance":data[20],
                    "meal_allowance":data[22],
                    "leave_travel_allowance":data[23],
                    "professional_development_allowance":data[24],
                    "performance_based_allowance":data[25],
                    "public_holiday_allowance":data[26],
                    'insurance':insurance,
                }
            }

            return jsonify(response_data), 200
        except Exception as e:
            print("Error occurred:", e)
            response_data = {
                "success": False,
                "error": str(e),
                "message": "Error occurred while generating salary slip."
            }
            return jsonify(response_data), 500
    
    # If the request method is not PUT, return a 405 Method Not Allowed error
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts PUT requests."}), 400
    
@app.route('/delete_slip/<id>',methods=["DELETE"])
def delete_slip(id):
    
    cursor = mysql.connection.cursor()
    cursor.execute("select * from payroll_management where id = %s",(id,))
    user = cursor.fetchone()
    
    if not user:
        return jsonify({"status":False,"message":"Form validation error","error":"Employee ID not found."}),404
    
    cursor.callproc('delete_payroll',[id])
    mysql.connection.commit()
    cursor.close()
    
    return jsonify({"status":True,
                    "message":"Salary slip deleted successfully",
                    "data": id}),200
    
def num2words(num):
    under_20 = ['Zero','One','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen']
    tens = ['Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety']
    above_100 = {100: 'Hundred and',1000:'Thousand', 100000:'Lakhs', 10000000:'Crores'}

    if num < 20:
         return under_20[num]

    if num < 100:
        return tens[(int)(num/10)-2] + ('' if num%10==0 else ' ' + under_20[num%10])

    # find the appropriate pivot - 'Million' in 3,603,550, or 'Thousand' in 603,550
    pivot = max([key for key in above_100.keys() if key <= num])

    return num2words((int)(num/pivot)) + ' ' + above_100[pivot] + ('' if num%pivot==0 else ' ' + num2words(num%pivot))

from io import BytesIO
@app.route('/generate_payslip_pdf/<employee_code>/<year>/<month_name>', methods=['POST'])
def generate_payslip_pdf(employee_code,year,month_name):
    try:
        # Fetch employee data from the database
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT employee_code, full_name, department, role FROM personal_information WHERE employee_code = %s", (employee_code,))
        employee_data = cursor.fetchone()

        # Check if employee exists
        if not employee_data:
            return jsonify({"success": False, "message": "Employee not found in the database"}), 200
        if month_name is None:
            raise ValueError("Month name is missing in the request")

            # Convert month name to zero-padded string representation
        month = month_name_to_number.get(month_name.lower())
        if month is None:
            raise ValueError("Invalid month name")
        
        cursor.execute("""SELECT ctc, medical_allowance, total_salary, basic_salary, hra, da, tax, pf, total_deduction, tds, net_salary, total_allowance, special_allowance, 
            total_working_days, year, month, travel_allowance, telephone_allowance,shift_allowance, meal_allowance,leave_travel_allowance,professional_development_allowance,
            performance_based_allowance,public_holiday_allowance,insurance FROM payroll_management WHERE ref_employee_code = %s and year = %s and month = %s and is_active = 1
                       """, (employee_code,year,month))
        data = cursor.fetchone()
        # year = data[14]
        # month = calendar.month_name[data[15]]
        
        net_salary = data[10]
        net_salary_in_words = num2words(net_salary)
        
        bold_style = ParagraphStyle(
            name='Bold',
            fontSize=11,
            textColor=colors.black,
            alignment=1,
            spaceAfter=5,
            fontName='Helvetica-Bold'
        )
        font_total_style = ParagraphStyle(
            name='Bold',
            fontSize=10,
            textColor=colors.black,
            alignment=0,
            spaceAfter=5,
            fontName='Helvetica-Bold'
        )
        font_value_style = ParagraphStyle(
            name='Bold',
            fontSize=10,
            textColor=colors.black,
            alignment=2,
            spaceAfter=5,
            fontName='Helvetica-Bold'
        )

        # Define earnings data for the earnings table
        earnings_data = [
            ["Basic Salary", f"{data[3]:.2f}",f"{data[3]:.2f}"],
            ["HRA", f"{data[4]:.2f}", f"{data[4]:.2f}"],
            ["DA", f"{data[5]:.2f}", f"{data[5]:.2f}"],
            ["Medical Allowance", f"{data[1]:.2f}", f"{data[1]:.2f}"],
            ["Special Allowance", f"{data[12]:.2f}", f"{data[12]:.2f}"],
            ["Telephone Allowance", f"{data[17]:.2f}", f"{data[17]:.2f}"],
            ["Travel Allowance", f"{data[16]:.2f}", f"{data[16]:.2f}"],
            ["Meal Allowance", "", f"{data[19]:.2f}"],
            ["Shift Allowance", "", f"{data[18]:.2f}"],
            ["Leave Travel Allowance", "", f"{data[20]:.2f}"],
            # ["Professional Development Allowance", "", f"{data[21]:.2f}"],
            ["PDA", "", f"{data[21]:.2f}"],
            # ["Performance Based Allowance", "", f"{data[22]:.2f}"],
            ["PBA", "", f"{data[22]:.2f}"],
            ["Public Holiday Pay", "", f"{data[23]:.2f}"],
            ["Total Allowance", "", f"{data[11]:.2f}"],
            ["Total Salary", float(data[0]/12), float(data[2])]
        ]

        # Define deduction data for the deductions table
        deductions_data = [
            ["Professional Tax", f"{data[6]:.2f}"],
            ["PF", f"{data[7]:.2f}"],
            ["TDS", f"{data[9]:.2f}"],
            ["Insurance", f"{data[24]:.2f}"],
            ["Total Deduction", float(data[8])]
        ]

        # Combine earnings and deductions data side by side
        combined_table_data = []

        # Add header row
        combined_table_data.append([
            Paragraph("Earnings", bold_style),Paragraph("Fixed Amount", bold_style), Paragraph("Amount", bold_style),
            Paragraph("Deductions", bold_style), Paragraph("Amount", bold_style)
        ])

        # Find index of "Total Salary" in `earnings_data`
        total_salary_index = None
        for i, row in enumerate(earnings_data):
            if row[0] == "Total Salary":
                total_salary_index = i
                break

        # Extract the "Total Deduction" row from `deductions_data`
        total_deduction_row = None
        for i, row in enumerate(deductions_data):
            if row[0] == "Total Deduction":
                total_deduction_row = row
                deductions_data.pop(i)  # Remove the row from its original position
                break

        # Extract the "Total Salary" row from `earnings_data`
        if total_salary_index is not None:
            total_salary_row = earnings_data.pop(total_salary_index)  # Remove "Total Salary" row from earnings_data

        # Combine earnings and deductions data side by side, omitting "Total Salary"
        for i in range(max(len(earnings_data), len(deductions_data))):
            # Get earnings row if within range
            earnings_row = earnings_data[i] if i < len(earnings_data) else ["","", ""]
            # Get deductions row if within range
            deductions_row = deductions_data[i] if i < len(deductions_data) else ["", ""]
            
            # Combine rows and add to the combined table data list
            combined_row = earnings_row + deductions_row
            combined_table_data.append(combined_row)

        # Calculate the insertion index for inserting "Total Salary" and "Total Deduction"
        insertion_index = None
        if total_deduction_row and total_salary_row:
            # Calculate insertion index: one row below "Total Deduction" without an empty row
            insertion_index = len(combined_table_data)  # Since "Total Deduction" was removed, it will be the last index

        # Insert the combined row for "Total Salary" and "Total Deduction"
        if total_deduction_row and total_salary_row and insertion_index is not None:
            combined_row = [Paragraph(total_salary_row[0],font_total_style),Paragraph(f"{total_salary_row[1]:.2f}",font_value_style),Paragraph(f"{total_salary_row[2]:.2f}",font_value_style),
                            Paragraph(total_deduction_row[0],font_total_style), Paragraph(f"{total_deduction_row[1]:.2f}",font_value_style)]
            combined_table_data.insert(insertion_index, combined_row)
            combined_table_data.insert(insertion_index,["","","","",""])

         # Insert net salary row with the net salary in words
        combined_table_data.append([
            Paragraph(f"Net Salary : {net_salary:.2f} ({net_salary_in_words} only.)", font_total_style),
            "", "", ""  # Empty cells for alignment
        ])
        
        # Create the combined table
        combined_table = Table(combined_table_data, colWidths=[140,100, 80, 130, 80])
        
        # Style the combined table
        combined_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (4, 0), colors.lightblue),
            ('TEXTCOLOR', (0, 0), (4, 0), colors.black),
            ('ALIGN', (0, 0), (4, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (4, -1), 'Helvetica'),
            ('GRID', (0, 0), (4, -1), 0.5, colors.black),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('ALIGN', (0, 1), (0, -1), 'LEFT'),
            ('ALIGN', (2, 1), (2, -1), 'RIGHT'),
            ('ALIGN', (1,1),(1,-1),'RIGHT'),
            ('ALIGN', (3,1),(3,-1),'LEFT'),
            ('ALIGN', (4,1),(4,-1),'RIGHT'),
            # Add background color for "Total Salary" and "Total Deduction" rows
            ('BACKGROUND', (0, insertion_index+1), (1, insertion_index+1), colors.lightgrey), # "Total Salary" row
            ('BACKGROUND', (2,insertion_index+1), (4, insertion_index+1), colors.lightgrey), # "Total Deduction" row
            # Span the net salary row
            ('SPAN', (0, -1), (4, -1))
        ]))
        
        # Buffer to hold the generated PDF
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)

        # Define PageTemplate with a footer containing the company address and separation line
        def footer(canvas, doc):
            company_address = """745/746/19, 8th main, 6th Cross Road, Mahalakshmi Layout, 
            Bengaluru, Karnataka 560086."""
            address_style = ParagraphStyle(
                name='Address',
                fontSize=11,
                textColor=colors.black,
                alignment=1
            )
            address_paragraph = Paragraph(company_address, address_style)
            w, h = address_paragraph.wrap(doc.width, doc.bottomMargin)

            # Draw separation line
            line_y = h + 22 # Adjusted position to give some space between line and address
            line_x = w + 50
            canvas.line(doc.leftMargin - 50, line_y, line_x + doc.leftMargin, line_y)
            
            # Draw address
            address_paragraph.drawOn(canvas, doc.leftMargin, h)

        # Add header content here
        def header(canvas, doc):
            company_logo_path = r"/home/fi2e8gs31z4n/projecthrms/atraya.jpg"
            logo = Image(company_logo_path, width=250, height=65)
            logo.drawOn(canvas, 175, 720)  # Adjust position as needed
            canvas.line(20, 715, 592, 715)  # Adjust coordinates as needed

        # Add header and footer to the document
        doc._calc()  # Call this function to calculate the number of pages
        doc.onFirstPage = lambda canvas, doc: (header(canvas, doc), footer(canvas, doc))
        doc.onLaterPages = lambda canvas, doc: footer(canvas, doc)

        # Create Paragraph styles
        heading_style = ParagraphStyle(
            name='Heading',
            fontSize=11,
            textColor=colors.black,
            alignment=0,
            spaceAfter=7,
            fontName='Helvetica-Bold'
        )

        title_style = ParagraphStyle(
            name='Title',
            fontSize=15,
            textColor=colors.black,
            alignment=1,
            spaceAfter=20,
            spaceBefore=20,
            fontName='Times-Roman',
            fontWeight='Bold'
        )

        # Create a Paragraph for the heading
        heading_text = f"Pay Slip of Employee ID {employee_code} for {calendar.month_name[int(month)]}, {year}"
        heading = Paragraph(heading_text, title_style)

        header_style = ParagraphStyle(
            name='Header',
            fontSize=10,
            textColor=colors.black,
            alignment=0,
            # leftIndent=0,
            fontName='Helvetica-Bold',
        )
        value_style = ParagraphStyle(
            name='Value',
            fontSize=9,
            textColor=colors.black,
            alignment=0
        )
        employee_info_heading = Paragraph("Employee Information :", heading_style)
        
        employee_info_table_data = [[employee_info_heading,"","",""],
            [
                Paragraph("Employee Code", header_style),
                Paragraph(str(employee_data[0]), value_style),
                Paragraph("Full Name", header_style),
                Paragraph(employee_data[1], value_style)
            ],
            [
                Paragraph("Department", header_style),
                Paragraph(employee_data[2], value_style),
                Paragraph("Designation", header_style),
                Paragraph(employee_data[3], value_style)
            ],
            [
                Paragraph("CTC", header_style),
                Paragraph(str(data[0]), value_style),
                Paragraph("Total Working Days", header_style),
                Paragraph(str(data[13]), value_style)
            ]
        ]

        # Create the table for employee information
        employee_info_table = Table(employee_info_table_data, colWidths=[90, 165,  110, 145], rowHeights=(20))

        # Customize the table style for aesthetics
        employee_info_table.setStyle(TableStyle([
            ('VALIGN', (0,0), (0,0), 'MIDDLE'),
            # ('FONTSIZE', (0, 0), (-1, -1), 12),  # Set font size for all cells
            ('INNERGRID', (0, 0), (-1, -1), 0.5, colors.black),  # Add grid lines between cells
            ('BOX', (0, 0), (-1, -1), 0.5, colors.black),  # Add border around the table
            ('BACKGROUND',(0,0),(-1,-1), colors.white),
            # Make the heading row bold and centered
            ('SPAN', (0, 0), (-1, 0)),
            ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
            # ('SPAN', (0, 1), (-1, 1)),# Span the heading across all columns
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),
        ]))
        
        # Add content to the PDF document
        content = []
        content.append(Spacer(1, 10))
        content.append(heading)
        content.append(Spacer(1, 10))
        content.append(employee_info_table)
        content.append(Spacer(1, 10))
        content.append(combined_table)
        content.append(Spacer(1, 10))
        last = Paragraph("This is a computer-generated document and does not require a signature.",
                           ParagraphStyle(name='Footer', fontSize=10, alignment=1, textColor=colors.grey))
        content.append(last)
        
        # Build the PDF document
        doc.build(content)
        # Move the buffer position to the beginning
        buffer.seek(0)

        # Close the cursor
        cursor.close()
        
        # Return the generated PDF file for download
        return send_file(buffer, as_attachment=True, download_name=f"{employee_code}_{year}_{month}_payslip.pdf", mimetype='application/pdf')

    except Exception as e:
        print("Error occurred:", e)
        return jsonify({"success": False, "error": str(e), "message": "Error occurred while generating PDF"}), 500

@app.route('/payroll_view/<ref_employee_code>/<year>/<month_name>', methods = ['GET'])
def payroll_view(ref_employee_code,year,month_name):
    try:

            # Check if month_name is provided and not None
        if month_name is None:
            return jsonify({'status':False,'message':"Month name is missing in the request"}), 400

                # Convert month name to zero-padded string representation
        month = month_name_to_number.get(month_name.lower())
        if month is None:
            return jsonify({'status':False,'message':"Invalid month name"}),400

        cursor = mysql.connection.cursor()
        cursor.callproc('payroll_view_generate', [ref_employee_code,year,month])
        user = cursor.fetchone()

        if not user:
            return jsonify({'status':False,'message':'Salary data not found.'}),404

        cursor.execute("SELECT full_name, department, role FROM personal_information WHERE employee_code = %s", (ref_employee_code,))
        employee_data = cursor.fetchone()
        cursor.close()

        if user:
            month_name = calendar.month_name[user[15]]
            payroll_data = {
                    'ref_employee_code' : ref_employee_code,
                    'full_name' : employee_data[0],
                    'department' : employee_data[1],
                    'role' : employee_data[2],
                    "ctc": user[0],
                    "medical_allowance": user[1],
                    "total_salary": user[2],
                    "basic_salary": user[3],
                    "hra": user[4],
                    "da": user[5],
                    "tax": user[6],
                    "pf": user[7],
                    "total_deduction": user[8],
                    "tds": user[9],
                    "net_salary": user[10],
                    "total_allowance": user[11],
                    "special_allowance": user[12],
                    "paid_days": user[13],
                    "year": user[14],
                    "month": month_name,
                    "location":user[16],
                        # "year":year,
                    # "month":f"{calendar.month_name[int(month)]} {year}",
                    "travel_allowance":user[17],
                    "telephone_allowance":user[18],
                    "shift_allowance":user[19],
                    "meal_allowance":user[20],
                    "leave_travel_allowance":user[21],
                    "professional_development_allowance":user[22],
                    "performance_based_allowance":user[23],
                    "public_holiday_allowance":user[24],
                    "tax_regime":user[25],
                    "insurance":user[26]
                }

        # if pay_list:
            return jsonify({"status": True,"message":f"Payroll for {month_name}." ,"data": payroll_data}),200
        else:
            return jsonify({"status": False, "message": "Employee not found"}), 404
    except Exception as e:
        return jsonify({'status': False, 'message':f'{str(e)}.'}), 500
    
@app.route('/payroll_list', methods=['GET'])
def salary_pagination():
    total_records = request.args.get('total_records', type=int)
    per_page = request.args.get('per_page', default=10, type=int)
    
    if total_records is None:
        # Fetch total active records from the database
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT COUNT(*) FROM payroll_management WHERE is_active = 1")
        total_records = cursor.fetchone()[0]
        cursor.close()
        
    # Calculate the total number of pages
    total_pages = total_records // per_page
    if total_records % per_page != 0:
        total_pages += 1
    
    # Extract page number from the request
    page = request.args.get('page', default=1, type=int)
    
    # If the page is greater than the total pages, return empty data
    if page > total_pages:
        return jsonify({'status': False, 'message': 'Page not found', 'data': []}), 200
    
    # Calculate the offset
    offset = (page - 1) * per_page
    
    # If it's the last page and there are fewer records than per_page, adjust per_page
    if page == total_pages and total_records % per_page != 0:
        per_page = total_records % per_page
        
    cursor = mysql.connection.cursor()
    cursor.callproc('salary_pagination', [per_page, offset])
    userpay = cursor.fetchall()
    cursor.close()
    
    pay_list = []
    for user in userpay:
        month_name = calendar.month_name[user[15]]
        payroll_data = {
            "ref_employee_code": user[16],
            "ctc": user[0],
            "medical_allowance": user[1],
            "total_salary": user[2],
            "basic_salary": user[3],
            "hra": user[4],
            "da": user[5],
            "tax": user[6],
            "pf": user[7],
            "total_deduction": user[8],
            "tds": user[9],
            "net_salary": user[10],
            "total_allowance": user[11],
            "special_allowance": user[12],
            "total_working_days": user[13],
            "year": user[14],
            "month": month_name,
            "travel_allowance": user[17],
            "telephone_allowance": user[18],
            "shift_allowance": user[19],
            "meal_allowance": user[20],
            "leave_travel_allowance": user[21],
            "professional_development_allowance": user[22],
            "performance_based_allowance": user[23],
            "public_holiday_allowance": user[24],
            "id": user[25],
            "location": user[26],
            'full_name': user[27],
            "tax_regime" : user[28],
            "insurance" : user[29]
        }
        pay_list.append(payroll_data)
    
    return jsonify({
        "status": True,
        "message": "Displaying paginated data",
        "page": page,
        "per_page": per_page,
        "total_records": total_records,
        "total_pages": total_pages,
        "data": pay_list
    }), 200
    
##################################### Salary management ends here #########################################

##################################### PF management starts here ########################################
@app.route('/pf_management', methods=['POST'])
def add_pf_record():
    data = request.get_json()
    ref_employee_code = data.get('ref_employee_code')
    basic_salary = data.get('basic_salary')

    if not ref_employee_code or not basic_salary:
        return jsonify({'error': 'Missing ref_employee_code or basic_salary'}), 400

    # Define the rates
    employee_pf_rate = 0.12  # 12% of Basic Salary for Employee PF Contribution
    employer_total_pf_rate = 0.12  # 12% of Basic Salary for Employer's Total PF Contribution
    eps_rate = 0.0833  # 8.33% of Basic Salary for EPS
    eps_salary_cap = 15000  # Salary cap for EPS calculation

    # Convert basic salary to an integer for proper calculations
    basic_salary = int(float(basic_salary))

    # Calculate Employee's PF Contribution (12% of Basic Salary)
    employee_pf_contribution = round(basic_salary * employee_pf_rate, 0)

    # Employers total PF contribution (12% of Basic Salary)
    employer_total_pf_contribution = round(basic_salary * employer_total_pf_rate, 0)

    # Employers EPS Contribution (8.33% of capped salary at 15,000)
    capped_salary = min(basic_salary, eps_salary_cap)
    eps_contribution = round(capped_salary * eps_rate, 0)

    # Employers EPF Contribution (Remaining part after EPS)
    epf_contribution = round(employer_total_pf_contribution - eps_contribution, 0)

    # Total PF Contribution (Employee PF + Employer EPF)
    total_pf_contribution = round(employee_pf_contribution + epf_contribution, 0)

    #Total deduction
    total_deduction = round(employee_pf_contribution+employer_total_pf_contribution,0)

    cursor = mysql.connection.cursor()

    try:
        # Check if a PF record already exists for the employee for the current month and year
        cursor.execute("""
            SELECT COUNT(*) FROM pf_management 
            WHERE ref_employee_code = %s
            AND MONTH(created_at) = MONTH(CURDATE())
            AND YEAR(created_at) = YEAR(CURDATE())
            AND is_active = 1
        """, (ref_employee_code,))
        record_count = cursor.fetchone()[0]

        if record_count > 0:
            return jsonify({
                "status": False,
                "message": f"PF record already exists for employee {ref_employee_code} for this month."
            }), 409  # Conflict status code

        # Call the stored procedure with default values for created_by and is_active
        cursor.callproc('insert_PFManagement', (
            ref_employee_code,  
            basic_salary,  
            employee_pf_contribution, 
            epf_contribution,  
            eps_contribution,  
            employer_total_pf_contribution,  
            total_pf_contribution, 
            total_deduction, 
            1  
        ))

        # Commit the transaction
        mysql.connection.commit()

    except Exception as e:
        # Handle specific exceptions
        if "Duplicate entry" in str(e):  # Adjust this check based on your actual DB error messages
            return jsonify({
                "status": False,
                "message": f"PF record already exists for employee {ref_employee_code} for this month."
            }), 409  # Conflict status code
        else:
            return jsonify({
                "status": False,
                "message": f"An error occurred: {str(e)}"
            }), 500

    finally:
        cursor.close()

    # Return the calculated PF details
    return jsonify({
        'status':True,
        'message': 'PF details calculated and stored successfully',
        'data': {
            'ref_employee_code': ref_employee_code,
            'basic_salary': round(basic_salary, 2),
            'employee_pf': employee_pf_contribution,
            'employer_epf': epf_contribution,
            'employer_eps': eps_contribution,
            'employer_pf': employer_total_pf_contribution,
            'total_pf': total_pf_contribution,
            'total_deduction':total_deduction
        }
    }), 200

@app.route('/pf_list', methods=['GET'])
def pf_pagination(): 
    per_page = request.args.get('per_page', default=10, type=int)  # Items per page
    page = request.args.get('page', default=1, type=int)  # Current page

    # Fetch total record count
    cursor = mysql.connection.cursor()
    cursor.execute("SELECT COUNT(*) FROM pf_management WHERE is_active = 1")
    total_records = cursor.fetchone()[0]

    # Calculate the total number of pages
    total_pages = (total_records + per_page - 1) // per_page

    # If the requested page is out of range
    if page > total_pages:
        return jsonify({
            'status': False,
            'message': 'Page not found',
            'data': []
        }), 200

    # Calculate the offset for pagination
    offset = (page - 1) * per_page

    # Call the stored procedure for fetching paginated PF records
    cursor.callproc('get_pf_management_pagination', (per_page, offset))

    # Fetch paginated records
    pf_records = cursor.fetchall()
    cursor.close()

    # Create the PF list
    pf_list = []
    for record in pf_records:
        pf_data = {
            'id': record[0],
            'ref_employee_code': record[1],
            'basic_salary': record[2],
            'employee_pf': record[3],
            'employer_epf': record[4],
            'employer_eps': record[5],
            'employer_pf': record[6],
            'total_pf': record[7],
           'total_deduction':record[8],
            'full_name': record[9],
            'department': record[10],
            'role': record[11]
        }
        pf_list.append(pf_data)

    # Return the response with pagination info
    return jsonify({
        "status": True,
        "message": "Displaying paginated PF data",
        "page": page,
        "per_page": per_page,
        "total_records": total_records,
        "total_pages": total_pages,
        "data": pf_list
    }), 200

@app.route('/update_pf_management/<int:id>', methods=['POST'])
def update_pf_record(id):
    data = request.get_json()
    ref_employee_code = data.get('ref_employee_code')
    basic_salary = data.get('basic_salary')

    if not ref_employee_code or not basic_salary:
        return jsonify({'error': 'Missing ref_employee_code or basic_salary'}), 400

    # Define the rates
    employee_pf_rate = 0.12  # 12% of Basic Salary for Employee PF Contribution
    employer_total_pf_rate = 0.12  # 12% of Basic Salary for Employer's Total PF Contribution
    eps_rate = 0.0833  # 8.33% of Basic Salary for EPS
    eps_salary_cap = 15000  # Salary cap for EPS calculation

    # Convert basic salary to an integer for proper calculations
    basic_salary = int(float(basic_salary))

    # Calculate Employee's PF Contribution (12% of Basic Salary)
    employee_pf_contribution = round(basic_salary * employee_pf_rate, 0)

    # Employers total PF contribution (12% of Basic Salary)
    employer_total_pf_contribution = round(basic_salary * employer_total_pf_rate, 0)

    # Employers EPS Contribution (8.33% of capped salary at 15,000)
    capped_salary = min(basic_salary, eps_salary_cap)
    eps_contribution = round(capped_salary * eps_rate, 0)

    # Employers EPF Contribution (Remaining part after EPS)
    epf_contribution = round(employer_total_pf_contribution - eps_contribution, 0)

    # Total PF Contribution (Employee PF + Employer EPF)
    total_pf_contribution = round(employee_pf_contribution + epf_contribution, 0)

    # Total deduction
    total_deduction = round(employee_pf_contribution + employer_total_pf_contribution, 0)

    cursor = mysql.connection.cursor()

    try:
        # Call the stored procedure with the updated values
        cursor.callproc('update_pf_management', (
            id,  # p_id (Primary key of the PF record)
            ref_employee_code,  # p_ref_employee_code
            basic_salary,  # p_basic_salary
            employee_pf_contribution,  # p_employee_pf
            epf_contribution,  # p_employer_epf
            eps_contribution,  # p_employer_eps
            employer_total_pf_contribution,  # p_employer_pf
            total_pf_contribution,  # p_total_pf
            total_deduction
        ))

        # Commit the transaction
        mysql.connection.commit()
        cursor.close()
        
        cursor = mysql.connection.cursor()
        # Fetch the updated PF details (optional, if needed for response)
        cursor.execute("SELECT ref_employee_code, basic_salary, employee_pf, employer_epf, employer_eps, employer_pf, total_pf, total_deduction FROM pf_management WHERE id = %s", (id,))
        updated_pf = cursor.fetchone()

        if updated_pf is None:
            return jsonify({'error': 'PF record not found'}), 404

        # Return a structured response with meaningful field names
        pf_data = {
            'ref_employee_code': updated_pf[0],
            'basic_salary': updated_pf[1],
            'employee_pf': updated_pf[2],
            'employer_epf': updated_pf[3],
            'employer_eps': updated_pf[4],
            'employer_pf': updated_pf[5],
            'total_pf': updated_pf[6],
            'total_deduction': updated_pf[7]
        }

        return jsonify({'message': 'PF details updated successfully', 'pf_details': pf_data}), 200

    except Exception as e:
        mysql.connection.rollback()
        return jsonify({'error': str(e)}), 500

    finally:
        cursor.close()



@app.route('/delete_pf_employee/<id>', methods=["DELETE"])
def delete_pf_employee(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT * FROM pf_management WHERE id= %s", (id,))
        user = cursor.fetchone()
        
        if not user:
            cursor.close()
            return jsonify({"status": "false", "message": "Form validation error", "error": "Employee ID not found."})
        
        # Call the stored procedure to deactivate the employee
        cursor.callproc('DeactivatePFEmployee', (id,))
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({"status": "true",
                        "message": "Employee deactivated successfully",
                        "data": id})
    
    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
##########################################################start_pf_report######################################################################

@app.route('/pf_list_by_date/<string:start_date>/<string:end_date>', methods=['GET'])
def pf_list_by_date(start_date, end_date):
    try:
        # Convert start_date and end_date strings to datetime objects
        start_date_obj = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date_obj = datetime.strptime(end_date, '%Y-%m-%d').date()

        cursor = mysql.connection.cursor()

        # Call the stored procedure to fetch PF records within the date range
        cursor.callproc('get_pf_list_by_date', (start_date_obj, end_date_obj))
        
        pf_records = cursor.fetchall()
        cursor.close()

        # Create the PF list
        pf_list = []
        for record in pf_records:
            pf_data = {
                'id': record[0],
                'ref_employee_code': record[1],
                'basic_salary': record[2],
                'employee_pf': record[3],
                'employer_epf': record[4],
                'employer_eps': record[5],
                'employer_pf': record[6],
                'total_pf': record[7],
                'total_deduction':record[8]
            }
            pf_list.append(pf_data)

        return jsonify({
            "status": True,
            "message": "Displaying PF data for the given date range",
            "start_date": start_date,
            "end_date": end_date,
            "data": pf_list
        }), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/count_active_employees', methods=['GET'])
def count_active_employees():
    try:
        cursor = mysql.connection.cursor()
 
        # Count the number of active employees
        cursor.callproc("count_active_pf")
        result = cursor.fetchone()
        active_employee_count = result[0] if result else 0

        cursor.close()

        return jsonify({'success': True, 'message': 'Active employee count retrieved successfully', 'active_employee_count': active_employee_count}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


@app.route('/pf_list_by_code/<string:employee_code>', methods=['GET'])
def pf_list_by_code(employee_code):
    per_page = request.args.get('per_page', default=10, type=int)  # Items per page
    page = request.args.get('page', default=1, type=int)  # Current page

    if not employee_code:
        return jsonify({'status': False, 'message': 'Missing employee_code', 'data': []}), 400

    # Fetch total record count for the specified employee code
    cursor = mysql.connection.cursor()
    cursor.execute("""
        SELECT COUNT(*) 
        FROM pf_management 
        WHERE ref_employee_code = %s AND is_active = 1
    """, (employee_code,))
    total_records = cursor.fetchone()[0]

    # Calculate the total number of pages
    total_pages = (total_records + per_page - 1) // per_page

    # If the requested page is out of range
    if page > total_pages:
        return jsonify({
            'status': False,
            'message': 'Page not found',
            'data': []
        }), 200

    # Calculate the offset for pagination
    offset = (page - 1) * per_page

    # Call the stored procedure for fetching paginated PF records by employee code
    cursor.callproc('get_pf_management_by_code_pagination', (employee_code, per_page, offset))

    # Fetch paginated records
    pf_records = cursor.fetchall()
    cursor.close()

    # Create the PF list
    pf_list = []
    for record in pf_records:
        pf_data = {
            'id': record[0],
            'ref_employee_code': record[1],
            'basic_salary': record[2],
            'employee_pf': record[3],
            'employer_epf': record[4],
            'employer_eps': record[5],
            'employer_pf': record[6],
            'total_pf': record[7],
            'total_deduction': record[8],
            'full_name': record[9],
            'department': record[10],
            'role': record[11]
        }
        pf_list.append(pf_data)

    # Return the response with pagination info
    return jsonify({
        "status": True,
        "message": "Displaying paginated PF data by employee code",
        "page": page,
        "per_page": per_page,
        "total_records": total_records,
        "total_pages": total_pages,
        "data": pf_list
    }), 200


@app.route('/epf_contribution_pie/<string:employee_code>', methods=['GET'])
def epf_contribution_pie(employee_code):
    try:
        cursor = mysql.connection.cursor()

        # Query to get the total Employee PF and Employer PF contributions for the given employee
        cursor.execute("""
            SELECT 
                SUM(employee_pf) as total_employee_pf,
                SUM(employer_pf) as total_employer_pf
            FROM pf_management
            WHERE ref_employee_code = %s
            AND is_active = 1
        """, (employee_code,))

        pf_data = cursor.fetchone()
        cursor.close()

        # Log or print values for debugging
        print(f"Raw data from database: {pf_data}")

        if not pf_data:
            return jsonify({
                "status": False,
                "message": "No data found for the provided employee code."
            }), 404

        # Extract total Employee PF and Employer PF contributions
        total_employee_pf = float(pf_data[0]) if pf_data[0] is not None else 0
        total_employer_pf = float(pf_data[1]) if pf_data[1] is not None else 0

        # Prepare pie chart data
        pie_chart_data = [
            {"label": "Employee PF", "value": total_employee_pf},
            {"label": "Employer PF", "value": total_employer_pf}
        ]

        return jsonify({
            "status": True,
            "message": "Cumulative EPF Contribution Summary",
            "data": pie_chart_data
        }), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500

from datetime import datetime
from dateutil.relativedelta import relativedelta

def calculate_work_experience(date_of_joining):
    today = datetime.now()
    date_of_joining = datetime.strptime(date_of_joining, '%Y-%m-%d')

    # Calculate the difference in years, months, and days
    difference = relativedelta(today, date_of_joining)

    years = difference.years
    months = difference.months
    days = difference.days

    return f"{years} years {months} months {days} days"

@app.route('/get_personal_information/<int:employee_code>', methods=['GET'])
def get_personal_information(employee_code):
    try:
        cursor = mysql.connection.cursor()

        # Fetch personal information
        cursor.execute("""
            SELECT full_name, date_of_joining, company_name FROM personal_information 
            WHERE employee_code = %s
        """, (employee_code,))
        result = cursor.fetchone()

        if result is None:
            return jsonify({"error": "Employee not found."}), 404

        full_name, date_of_joining, company_name = result

        # Calculate work experience
        work_experience = calculate_work_experience(date_of_joining)

        # Construct response
        response = {
            "employee_code": employee_code,
            "full_name": full_name,
            "date_of_joining": date_of_joining,
            "company_name": company_name,
            "work_experience": work_experience
        }

        cursor.close()
        return jsonify(response), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500

#################################### PF management ends here ######################################## 

#################################### Grievance management starts here ######################################## 

@app.route('/grievance_management_list',methods = ['GET'])
def grievance_pagination():
    total_records = request.args.get('total_records', type=int)
    per_page = request.args.get('per_page', default=10,type=int)
    
    if total_records is None:
        # Fetch all records from the database
        cursor = mysql.connection.cursor()
        cursor.execute("""SELECT COUNT(*) FROM grievance_management WHERE is_active = 1""")
        total_records = cursor.fetchone()[0]
        
    # Calculate the total number of pages
    total_pages = total_records // per_page
    if total_records % per_page != 0 :
        total_pages += 1
    
    # Extract page number from the request    
    page = request.args.get('page', default=1, type=int)
    
    # If the page is greater than the total pages, return empty data
    if page > total_pages:
        return jsonify({'status':False,'message':'Page not found','data':[]}), 200
    
    # Calculate the offset
    offset = (page - 1) * per_page
    
    # If it's the last page and there are fewer records than per_page, adjust per_page
    if page == total_pages and total_records % per_page != 0:
        per_page = total_records % per_page
        
    cursor = mysql.connection.cursor()
    cursor.callproc('get_grievance_pagination',[per_page, offset])
    user = cursor.fetchall()
    cursor.close()
    
    complaints = []
    for user in user:
        data = {
            'id': user[7],
            'ref_employee_code' : user[0],
            'subject':user[1],
            "type_of_complaint" : user[2],
            "description" : user[3],
            "issue_date" : user[4].strftime('%d-%m-%Y'),
            "status" : user[5],
            "resolve_date" : user[6].strftime('%d-%m-%Y') if user[6] else None,
            "solution" : user[8],
            'full_name': user[9]
        }
        complaints.append(data)
    
    return jsonify({
        "status": True,
        "message": "Displaying paginated data",
        "page": page,
        "per_page": per_page,
        "total_records": total_records,
        "total_pages": total_pages,
        "data": complaints
    }), 200  
    
    
@app.route("/grievance_management", methods=['POST'])
def grievance_management():
    if request.method == 'POST' :
        try:
            data = request.json
            ref_employee_code = data.get('ref_employee_code')
            subject =   data.get('subject')
            type_of_complaint = data.get('type_of_complaint')
            description = data.get('description')
            issue_date = datetime.now().date()
            status = "Unsolved"
            
            cursor = mysql.connection.cursor()
            cursor.callproc('insert_grievance', (ref_employee_code, subject, type_of_complaint, description, issue_date, status))
            mysql.connection.commit()
            cursor.close()
            
            response = {
                'status' : True,
                'message' : 'Complaint raised successfully.',
                'data' : {
                    "ref_employee_code" : ref_employee_code,
                    "subject" : subject,
                    "type_of_complaint" : type_of_complaint,
                    "description" : description,
                    "issue_date" : issue_date.strftime('%Y-%m-%d'),
                    "status" : status
                } 
            }
            
            return jsonify(response),200
              
        except Exception as e:
            print("Error occurred:", e)
            return jsonify({"success": False, "error": str(e), "message": "Error posting complaint."}), 500
        
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts POST requests"}), 200

@app.route('/grievance_management_view/<ref_employee_code>/<issue_date>', methods=['GET'])
def grievance_management_view(ref_employee_code,issue_date):
    if request.method == 'GET' :
        try:
            issue_date_str = datetime.strptime(issue_date,'%d-%m-%Y').date()
            issue_date = issue_date_str.strftime('%Y-%m-%d')
            cursor = mysql.connection.cursor()
            cursor.execute("""select ref_employee_code,subject,type_of_complaint,description,issue_date,status,resolve_date,solution,
              resolved_by from grievance_management where ref_employee_code = %s and issue_date = %s""",(ref_employee_code,issue_date))
            user = cursor.fetchone()
            
            if user:
                data = {
                    'ref_employee_code' : user[0],
                    'subject':user[1],
                    "type_of_complaint" : user[2],
                    "description" : user[3],
                    "issue_date" : user[4].strftime('%d-%m-%Y'),
                    "status" : user[5],
                    "resolve_date" : user[6].strftime('%d-%m-%Y') if user[6] else None,
                    "resolved_by" : user[8],
                    "solution" : user[7]
                } 
            return jsonify({'status':True,'data':data})
        except Exception as e:
            print("Error occurred:", e)
            return jsonify({"success": False, "error": str(e), "message": "Error posting complaint."}), 500
        
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts POST requests"}), 405

@app.route('/update_grievance/<ref_employee_code>/<issue_date>', methods=['PUT'])
def update_grievance(ref_employee_code, issue_date):
    try:
        # Convert issue_date to the correct format
        issue_date_str = datetime.strptime(issue_date, '%d-%m-%Y').date()
        issue_date = issue_date_str.strftime('%Y-%m-%d')
        
        # Parse JSON request data
        data = request.json
        status = data.get('status')
        solution = data.get('solution')
        
        # Retrieve the resolved_by from session if the status is 'Resolved'
        resolved_by = session.get('employee_code') if status == 'Resolved' else None
        
        # Set resolve_date to current date if status is 'Resolved'
        resolve_date = datetime.now().date() if status == 'Resolved' else None
        
        # Connect to the database and execute stored procedure
        cursor = mysql.connection.cursor()
        cursor.callproc('update_grievance', (ref_employee_code, resolve_date, resolved_by, solution, issue_date, status))
        mysql.connection.commit()
        
        # Check if the update was successful
        if cursor.rowcount > 0:
            # Fetch updated data
            cursor.execute("""
                SELECT ref_employee_code, subject, type_of_complaint, description, issue_date, status, resolve_date, solution, resolved_by 
                FROM grievance_management 
                WHERE ref_employee_code = %s AND issue_date = %s
            """, (ref_employee_code, issue_date))
            updated_grievance = cursor.fetchone()
            
            if updated_grievance:
                data = {
                    'ref_employee_code': updated_grievance[0],
                    'subject': updated_grievance[1],
                    "type_of_complaint": updated_grievance[2],
                    "description": updated_grievance[3],
                    "issue_date": updated_grievance[4].strftime('%d-%m-%Y'),
                    "status": updated_grievance[5],
                    "resolve_date": updated_grievance[6].strftime('%d-%m-%Y') if updated_grievance[6] else None,
                    "resolved_by": updated_grievance[8],
                    "solution": updated_grievance[7]
                }
                return jsonify({'status': True, 'data': data, 'message':'Update saved successfully.'})
            else:
                return jsonify({'status': False, 'message': 'Failed to retrieve updated grievance.'}), 200
        else:
            return jsonify({'status': False, 'message': 'No rows updated.'}), 200

    except Exception as e:
        print("Error occurred:", e)
        return jsonify({"success": False, "error": str(e), "message": "Error updating grievance."}), 500

    finally:
        cursor.close()


@app.route('/grievance_employee_view/<ref_employee_code>', methods=['GET'])
def grievance_employee_view(ref_employee_code):
    if request.method == 'GET' :
        try:
            cursor = mysql.connection.cursor()
            cursor.execute("""select gm.ref_employee_code,gm.subject,gm.type_of_complaint,gm.description,gm.issue_date,gm.status,
                gm.solution,gm.resolve_date,gm.resolved_by,gm.id,pi.full_name 
                from grievance_management as gm
                join personal_information as pi
                on gm.ref_employee_code = pi.employee_code
                where gm.ref_employee_code = %s 
                """,(ref_employee_code,))
            user = cursor.fetchall()
            
            complaints = []
            for user in user:
                data = {
                    'ref_employee_code' : user[0],
                    'subject':user[1],
                    "type_of_complaint" : user[2],
                    "description" : user[3],
                    "issue_date" : user[4].strftime('%d-%m-%Y'),
                    "status" : user[5],
                    "resolve_date" : user[7].strftime('%d-%m-%Y') if user[6] else None,
                    "resolved_by" : user[8],
                    "solution" : user[6],
                    "id": user[9],
                    'full_name':user[10]
                }
                complaints.append(data)  
            return jsonify({'status':True,'data':complaints})
        except Exception as e:
            print("Error occurred:", e)
            return jsonify({"success": False, "error": str(e), "message": "Error posting complaint."}), 500
        
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts POST requests"}), 405
            
    
@app.route('/delete_grievance/<id>', methods=["DELETE"])
def delete_grievance(id):
    cursor = mysql.connection.cursor()
    cursor.execute("SELECT * FROM grievance_management WHERE id = %s", (id,))
    user = cursor.fetchone()
    
    if not user:
        return jsonify({"status": False, "message": "Form validation error", "error": "Complaint not found."})
    
    cursor.execute('UPDATE grievance_management SET is_active = 0 WHERE id = %s', (id,))
    mysql.connection.commit()
    cursor.close()
    
    return jsonify({"status": "true",
                    "message": f"Complaints of employee {user[1]} deleted successfully",
                    "data": user[1]}),200

######################################## Grievance management ends here ############################################

#################################### Attendance Report management starts here ######################################## 

@app.route('/attendance_report',methods=['GET'])
def attendance_report():
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("""select ref_employee_code,date,check_in,check_out,working_hours,status from attendance_management 
                    where is_active = 1 and status = 'Present' order by date desc""")
        attend = cursor.fetchall()
        cursor.close()
        
        attend_dict = []
        for attend in attend:
            data = {
                "ref_employee_code" : attend[0],
                "date" : attend[1].strftime('%Y-%m-%d'),
                "check_in" : attend[2],
                "check_out" : attend[3],
                "working_hours" : attend[4],
                "status" : attend[5]
            }
            attend_dict.append(data)
            
        response = {'status': True,'message':"Displaying attendance data.",'data':attend_dict}
        return jsonify(response),200
    except Exception as e:
        print('Error occurred : ',e)
        return jsonify({"status":True,"message":'Error fetching data.',"error":str(e)}),500
    
@app.route('/attendance_count',methods=['GET'])
def attendance_count():
    try:
        cursor = mysql.connection.cursor()
        cursor.callproc('count_attendance')
        count = cursor.fetchone()
        cursor.close()
        
        response = {"status":True,"message":'Count of attendies.',"data":count}
        return jsonify(response),200
    except Exception as e :
        print('Error : ', e)
        return jsonify({"status":False,"message":'error counting.',"error":str(e)}),500
    
@app.route('/attendance_report/<start_date>/<end_date>', methods=['GET'])
def attendance_report_by_range(start_date, end_date):
    try:
        # Convert start_date and end_date strings to datetime objects
        start_date = datetime.strptime(start_date, '%Y-%m-%d')
        end_date = datetime.strptime(end_date, '%Y-%m-%d')

        cursor = mysql.connection.cursor()
        cursor.execute("""SELECT am.ref_employee_code, am.date, am.check_in, am.check_out, am.working_hours, am.status, pi.full_name 
                          FROM attendance_management as am
                          join personal_information as pi
                          on am.ref_employee_code = pi.employee_code
                          WHERE am.is_active = 1 AND am.date BETWEEN %s AND %s and am.status = 'Present' order by am.date asc""", (start_date, end_date))
        attend = cursor.fetchall()
        cursor.close()

        attend_dict = []
        for attendance in attend:
            data = {
                "ref_employee_code": attendance[0],
                "date": attendance[1].strftime('%Y-%m-%d'),
                "check_in": attendance[2],
                "check_out": attendance[3],
                "working_hours": attendance[4],
                "status": attendance[5],
                'full_name': attendance[6]
            }
            attend_dict.append(data)

        response = {'status': True, 'message': "Displaying attendance data.", 'data': attend_dict}
        return jsonify(response), 200
    except Exception as e:
        print('Error occurred : ', e)
        return jsonify({"status": False, "message": 'Error fetching data.', "error": str(e)}), 500

#################################### Attendance Report management ends here ######################################## 

#################################### Salary Report management starts here ######################################## 

@app.route('/salary_count',methods=['GET'])
def salary_count():
    try:
        cursor = mysql.connection.cursor()
        cursor.callproc('count_salary_gen')
        count = cursor.fetchone()
        # count = count[0] if count else 0
        cursor.close()
        
        # response = {"status":True,"message":'Count of salary slip.',"data":count}
        return jsonify({"status":True,"message":'Count of salary slip.',"data":count}),200
    except Exception as e :
        print('Error : ', e)
        return jsonify({"status":False,"message":'error counting.',"error":str(e)}),500
    
@app.route('/salary_report/<start_date>/<end_date>', methods=['GET'])
def salary_report_by_range(start_date, end_date):
    try:
        # Convert start_date and end_date strings to datetime objects
        start_date = datetime.strptime(start_date, '%Y-%m-%d')
        end_date = datetime.strptime(end_date, '%Y-%m-%d')

        cursor = mysql.connection.cursor()
        cursor.execute("""SELECT pm.ctc, pm.medical_allowance, pm.total_salary, pm.basic_salary, pm.hra, pm.da, pm.tax, pm.pf, pm.total_deduction, pm.tds, pm.net_salary, 
        pm.total_allowance, pm.special_allowance, pm.total_working_days,pm.year,pm.month, pm.ref_employee_code, pm.location, pm.travel_allowance, pm.telephone_allowance,pm.shift_allowance,
        pm.meal_allowance,pm.leave_travel_allowance,pm.professional_development_allowance,pm.performance_based_allowance,pm.public_holiday_allowance, pi.full_name 
			FROM payroll_management as pm 
			join personal_information as pi
			on pm.ref_employee_code = pi.employee_code
			WHERE pm.is_active = 1 and date(pm.created_at) between %s and %s""", (start_date, end_date))
        salary = cursor.fetchall()
        cursor.close()

        pay_list = []
        for user in salary:
            month_name = calendar.month_name[user[15]]
            payroll_data = {
                    "ref_employee_code":user[16],
                    "ctc": user[0],
                    "medical_allowance": user[1],
                    "total_salary": user[2],
                    "basic_salary": user[3],
                    "hra": user[4],
                    "da": user[5],
                    "tax": user[6],
                    "pf": user[7],
                    "total_deduction": user[8],
                    "tds": user[9],
                    "net_salary": user[10],
                    "total_allowance": user[11],
                    "special_allowance": user[12],
                    "total_working_days": user[13],
                    "year": user[14],
                    "month":month_name,
                    "location" : user[17],
                    "travel_allowance":user[18],
                    "telephone_allowance":user[19],
                    "shift_allowance":user[20],
                    "meal_allowance":user[21],
                    "leave_travel_allowance":user[22],
                    "professional_development_allowance":user[23],
                    "performance_based_allowance":user[24],
                    "public_holiday_allowance":user[25],
                    'full_name': user[26]
                }
            pay_list.append(payroll_data)

        response = {'status': True, 'message': "Displaying attendance data.", 'data': pay_list}
        return jsonify(response), 200
    except Exception as e:
        print('Error occurred : ', e)
        return jsonify({"status": False, "message": 'Error fetching data.', "error": str(e)}), 500
    
@app.route('/salary_report_list/<employee_code>', methods=['GET'])
def salary_report_list(employee_code):
    try:
        per_page = request.args.get('per_page', default=10, type=int)
        page = request.args.get('page', default=1, type=int)

        cursor = mysql.connection.cursor()

        # Fetch total records if not provided in the request
        total_records = request.args.get('total_records', type=int)
        if total_records is None:
            cursor.execute("""
                SELECT COUNT(*) FROM payroll_management WHERE is_active = 1 AND ref_employee_code = %s
            """, (employee_code,))
            total_records = cursor.fetchone()[0]

        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1

        if page > total_pages:
            return jsonify({'status': False, 'message': 'Page not found.', 'data': []}), 200

        offset = (page - 1) * per_page

        cursor.execute("""
            SELECT pm.ctc, pm.medical_allowance, pm.total_salary, pm.basic_salary, pm.hra, pm.da, pm.tax, pm.pf, pm.total_deduction, pm.tds, pm.net_salary, pm.total_allowance, pm.special_allowance, 
            pm.total_working_days, pm.year, pm.month, pm.ref_employee_code, pm.location,pm.travel_allowance, pm.telephone_allowance,pm.shift_allowance,
        pm.meal_allowance,pm.leave_travel_allowance,pm.professional_development_allowance,pm.performance_based_allowance,pm.public_holiday_allowance,pi.full_name 
            FROM payroll_management as pm
            join personal_information as pi
            on pi.employee_code = pm.ref_employee_code
            WHERE pm.is_active = 1 AND pm.ref_employee_code = %s
            LIMIT %s OFFSET %s
        """, (employee_code, per_page, offset))

        salary = cursor.fetchall()
        cursor.close()

        pay_list = []
        for user in salary:
            month_name = calendar.month_name[user[15]]
            payroll_data = {
                "ref_employee_code": user[16],
                "ctc": user[0],
                "medical_allowance": user[1],
                "total_salary": user[2],
                "basic_salary": user[3],
                "hra": user[4],
                "da": user[5],
                "tax": user[6],
                "pf": user[7],
                "total_deduction": user[8],
                "tds": user[9],
                "net_salary": user[10],
                "total_allowance": user[11],
                "special_allowance": user[12],
                "total_working_days": user[13],
                "year": user[14],
                "month": f"{month_name}, {user[14]}",
                "location": user[17],
                "travel_allowance":user[18],
                "telephone_allowance":user[19],
                "shift_allowance":user[20],
                "meal_allowance":user[21],
                "leave_travel_allowance":user[22],
                "professional_development_allowance":user[23],
                "performance_based_allowance":user[24],
                "public_holiday_allowance":user[25],
                'full_name':user[26]
            }
            pay_list.append(payroll_data)

        return jsonify({
            "status": True,
            "message": f"Salary report for employee code {employee_code}",
            "data": pay_list,
            'page': page,
            'per_page': per_page,
            'total_records': total_records,
            'total_pages': total_pages
        }), 200

    except Exception as e:
        return jsonify({'status': False, 'message': f'An error occurred: {str(e)}'}), 500

#################################### Salary Report management ends here ########################################   

#################################### grievance report starts here #############################################

@app.route('/count_active_grievances', methods=['GET'])
def count_active_grievances():
    try:
        cursor = mysql.connection.cursor()

        # Count the number of active grievances for all employees
        cursor.callproc('count_grievance')
        result = cursor.fetchone()
        active_grievances_count = result[0] if result else 0

        cursor.close()

        return jsonify({'success': True, 'message': 'Active grievances count retrieved successfully', 'active_grievances_count': active_grievances_count}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/employee_grievances_details', methods=['GET'])
def employee_grievances_details():
    try:
        total_records = request.args.get('total_records', type=int)
        per_page = request.args.get('per_page', default=10, type=int)
        
        cursor = mysql.connection.cursor()
        
        # If total_records is not provided, calculate it
        if total_records is None:
            cursor.execute("""
                SELECT COUNT(*) 
                FROM personal_information pi
                LEFT JOIN grievance_management gm ON pi.employee_code = gm.ref_employee_code
                WHERE pi.is_active = 1 AND gm.is_active = 1
            """)
            total_records = cursor.fetchone()[0]

        # Calculate the total number of pages
        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1

        # Extract page number from the request
        page = request.args.get('page', default=1, type=int)
        
        # If the page is greater than the total pages, return empty data
        if page > total_pages:
            return jsonify({'success': False, 'message': 'Page not found', 'data': []}), 200
        
        # Calculate the offset
        offset = (page - 1) * per_page
        
        # Retrieve paginated employee details along with their grievances
        cursor.execute("""
            SELECT pi.employee_code, pi.full_name, pi.department, pi.role,
                   gm.subject, gm.type_of_complaint, gm.description, gm.issue_date, gm.status, gm.resolve_date
            FROM personal_information pi
            LEFT JOIN grievance_management gm ON pi.employee_code = gm.ref_employee_code
            WHERE pi.is_active = 1 AND gm.is_active = 1
            LIMIT %s OFFSET %s
        """, (per_page, offset))
        employee_grievances = cursor.fetchall()
        
        # Convert query result into a list of dictionaries
        result = []
        for row in employee_grievances:
            employee_data = {
                "employee_code": row[0],
                "full_name": row[1],
                "department": row[2],
                "role": row[3],
                "subject": row[4],
                "type_of_complaint": row[5],
                "description": row[6],
                "issue_date": row[7].strftime('%Y-%m-%d') if row[7] else None,
                "status": row[8],
                "resolve_date": row[9].strftime('%Y-%m-%d') if row[9] else None
            }
            result.append(employee_data)
        
        cursor.close()
        
        return jsonify({
            'success': True,
            'message': 'Employee details with grievances retrieved successfully',
            'page': page,
            'per_page': per_page,
            'total_records': total_records,
            'total_pages': total_pages,
            'data': result
        }), 200
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/employee_grievances_date/<start_date>/<end_date>', methods=['GET'])
def employee_grievances_date(start_date, end_date):
    try:
        # Convert string dates to datetime objects
        start_date = datetime.strptime(start_date, '%Y-%m-%d')
        end_date = datetime.strptime(end_date, '%Y-%m-%d')

        cursor = mysql.connection.cursor()

        # Retrieve employee details along with their grievances within the specified date range
        cursor.execute("""
            SELECT pi.employee_code, pi.full_name, pi.department, pi.role,
                   gm.subject, gm.type_of_complaint, gm.description, gm.issue_date, gm.status, gm.resolve_date
            FROM personal_information pi
            LEFT JOIN grievance_management gm ON pi.employee_code = gm.ref_employee_code
            WHERE pi.is_active = 1 AND gm.is_active = 1 AND gm.issue_date BETWEEN %s AND %s
        """, (start_date, end_date))
        employee_grievances = cursor.fetchall()

        # Convert query result into a list of dictionaries
        result = []
        for row in employee_grievances:
            employee_data = {
                "employee_code": row[0],
                "full_name": row[1],
                "department": row[2],
                "role": row[3],
                "subject": row[4],
                "type_of_complaint": row[5],
                "description": row[6],
                "issue_date": row[7].strftime('%d-%m-%Y') if row[7] else None,
                "status": row[8],
                "resolve_date": row[9].strftime('%d-%m-%Y') if row[9] else None
            }
            result.append(employee_data)

        cursor.close()

        return jsonify({'success': True, 'message': 'Employee details with grievances within the specified date range retrieved successfully', 'data': result}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/grievance_get_list/<employee_code>', methods=['GET'])
def grievance_get_list(employee_code):
    try:
        per_page = request.args.get('per_page', default=10, type=int)
        page = request.args.get('page', default=1, type=int)

        cursor = mysql.connection.cursor()

        # Fetch total records if not provided in the request
        total_records = request.args.get('total_records', type=int)
        if total_records is None:
            cursor.execute("""
                SELECT COUNT(*) FROM grievance_management AS gm
                INNER JOIN personal_information AS pi ON gm.ref_employee_code = pi.employee_code
                WHERE gm.is_active = 1 AND pi.employee_code = %s
            """, (employee_code,))
            total_records = cursor.fetchone()[0]

        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1

        if page > total_pages:
            return jsonify({'status': False, 'message': 'Page not found.', 'data': []}), 200

        offset = (page - 1) * per_page

        cursor.execute("""
            SELECT gm.ref_employee_code, gm.subject, gm.type_of_complaint, gm.description, gm.issue_date, gm.status, gm.resolve_date, gm.id,pi.full_name
            FROM grievance_management AS gm
            INNER JOIN personal_information AS pi ON gm.ref_employee_code = pi.employee_code
            WHERE gm.is_active = 1 AND pi.employee_code = %s
            ORDER BY gm.id DESC
            LIMIT %s OFFSET %s
        """, (employee_code, per_page, offset))

        user = cursor.fetchall()
        cursor.close()

        complaints = []
        for record in user:
            data = {
                'id': record[7],
                'employee_code': record[0],
                'subject': record[1],
                "type_of_complaint": record[2],
                "description": record[3],
                "issue_date": record[4].strftime('%Y-%m-%d'),
                "status": record[5],
                "resolve_date": record[6].strftime('%Y-%m-%d') if record[6] else None,
                "full_name": record[8]
            }
            complaints.append(data)

        return jsonify({
            'status': True,
            'message': f'Displaying grievance records for employee code {employee_code}.',
            'data': complaints,
            'page': page,
            'per_page': per_page,
            'total_records': total_records,
            'total_pages': total_pages
        }), 200

    except Exception as e:
        return jsonify({'status': False, 'message': f'An error occurred: {str(e)}'}), 500
#################################### grievance report end here ##################################################

#################################### Personal Report management starts here ########################################

@app.route('/count_active_personal_info', methods=['GET'])
def count_active_personal_info():
    try:
        cursor = mysql.connection.cursor()

        # Count the number of active employees in personal_information table
        cursor.callproc("count_active_personal_info")
        result = cursor.fetchone()
        active_personal_info_count = result[0] if result else 0

        cursor.close()

        return jsonify({'success': True, 'message': 'Active personal information count retrieved successfully', 'active_personal_info_count': active_personal_info_count}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
 
@app.route('/personal_information_date/<string:start_date>/<string:end_date>', methods=['GET'])
def personal_information_report_date(start_date, end_date):
    try:
        cursor = mysql.connection.cursor()

        # Convert start_date and end_date strings to datetime objects
        start_date_obj = datetime.strptime(start_date, '%d-%m-%Y')
        end_date_obj = datetime.strptime(end_date, '%d-%m-%Y')
        start = start_date_obj.strftime('%Y-%m-%d')
        end = end_date_obj.strftime('%Y-%m-%d')

        # Retrieve required personal information from the personal_information table within the specified range of date_of_joining
        cursor.execute("""
            SELECT 
                employee_code, full_name, address, gender, age, dob, role, email_id, mobile_number, highest_qualification, graduation_year,
                work_experience, department, marriage, bank_name, bank_acc_no, bank_ifsc_code, date_of_joining, status,company_name,institute_name
            FROM 
                personal_information
            WHERE
                STR_TO_DATE(date_of_joining, '%%Y-%%m-%%d') BETWEEN %s AND %s
        """, (start, end))
        personal_info_details = cursor.fetchall()

        personal_info_list_data = []
        for personal_info_detail in personal_info_details:
            employee_code, full_name, address, gender, age, dob, role, email_id, mobile_number, highest_qualification, graduation_year, work_experience, department, marriage, bank_name, bank_acc_no, bank_ifsc_code, date_of_joining, status,company_name,institute_name = personal_info_detail
            personal_info_list_data.append({
                'employee_code': employee_code,
                'full_name': full_name,
                'address': address,
                'gender': gender,
                'age': age,
                'dob': dob,  # No need to format as it's already a string
                'role': role,
                'email_id': email_id,
                'mobile_number': mobile_number,
                'highest_qualification': highest_qualification,
                'graduation_year': graduation_year,
                'work_experience': work_experience,
                'department': department,
                'marriage': marriage,
                'bank_name': bank_name,
                'bank_acc_no': bank_acc_no,
                'bank_ifsc_code': bank_ifsc_code,
                'date_of_joining': date_of_joining,  # No need to format as it's already a string
                'status': status,
                "company_name": company_name,
                "institute_name": institute_name
            })

        return jsonify({'success': True, 'message': 'Personal information report generated successfully', 'start_date': start_date, 'end_date': end_date, 'data': personal_info_list_data}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
 #################################### Personal Report management ends here ########################################  
 
 #################################### PF report management starts here ########################################
# @app.route('/pf_details_date/<string:start_date>/<string:end_date>', methods=['GET'])
# def pf_details_by_date(start_date, end_date):
#     try:
#         cursor = mysql.connection.cursor()

#         # Convert start_date and end_date strings to datetime objects
#         start_date_obj = datetime.strptime(start_date, '%Y-%m-%d').date()
#         end_date_obj = datetime.strptime(end_date, '%Y-%m-%d').date()

#         # Call the stored procedure to retrieve PF details within the specified range of created_at date
#         cursor.callproc('GetPFDetailsByDateRange', (start_date_obj, end_date_obj))
#         pf_details = cursor.fetchall()
#         cursor.close()

#         pf_list = []
#         for pf_detail in pf_details:
#             ref_employee_code, full_name, department, role, location, ctc, medical_allowance, month_salary, basic_salary, HRA, DA, professional_tax, pf_employee_contribution, pension_scheme_contribution, edli_contribution, pf_administrative_charges, total_employer_pf_contribution, total_deduction, total_pf_amount, special_allowance, gross_salary, tds, net_salary = pf_detail

#             pf_data = {
#                 'ref_employee_code': ref_employee_code,
#                 'full_name': full_name,
#                 'department': department,
#                 'role': role,
#                 'location': location,
#                 'ctc': round(float(ctc), 2),
#                 'medical_allowance': round(float(medical_allowance), 2),
#                 'month_salary': round(float(month_salary), 2),
#                 'basic_salary': round(float(basic_salary), 2),
#                 'DA': round(float(DA), 2),
#                 'HRA': round(float(HRA), 2),
#                 'professional_tax': round(float(professional_tax), 2),
#                 'pf_employee_contribution': round(float(pf_employee_contribution), 2),
#                 'pension_scheme_contribution': round(float(pension_scheme_contribution), 2),
#                 'edli_contribution': round(float(edli_contribution), 2),
#                 'pf_administrative_charges': round(float(pf_administrative_charges), 2),
#                 'total_employer_pf_contribution': round(float(total_employer_pf_contribution), 2),
#                 'total_deduction': round(float(total_deduction), 2),
#                 'total_pf_amount': round(float(total_pf_amount), 2),
#                 'special_allowance': round(float(special_allowance), 2),
#                 'gross_salary': round(float(gross_salary), 2),
#                 'tds': round(float(tds), 2),
#                 'net_salary': round(float(net_salary), 2)
#             }
#             pf_list.append(pf_data)

#         return jsonify({'success': True, 'message': 'PF details retrieved successfully', 'start_date': start_date, 'end_date': end_date, 'data': pf_list}), 200

#     except Exception as e:
#         return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

# @app.route('/count_active_employees', methods=['GET'])
# def count_active_employees():
#     try:
#         cursor = mysql.connection.cursor()

#         # Count the number of active employees
#         cursor.callproc("count_active_pf")
#         result = cursor.fetchone()
#         active_employee_count = result[0] if result else 0

#         cursor.close()

#         return jsonify({'success': True, 'message': 'Active employee count retrieved successfully', 'active_employee_count': active_employee_count}), 200

#     except Exception as e:
#         return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

# @app.route('/pf_list_by_code/<employee_code>', methods=['GET'])
# def get_pf_management_by_employee_code(employee_code):
#     try:
#         cursor = mysql.connection.cursor()

#         # Call the stored procedure
#         cursor.callproc('GetPFManagementByEmployeeCode', [employee_code,])
#         userpay = cursor.fetchall()
#         cursor.close()

#         pf_list = []
#         for user in userpay:
#             pf_data = {
#                 'id': user[0],
#                 'ref_employee_code': user[1],
#                 'location': user[2],
#                 'ctc': user[3],
#                 'medical_allowance': user[4],
#                 'basic_salary': user[5],
#                 'HRA': user[6],
#                 'DA': user[7],
#                 'professional_tax': user[8],
#                 'pf_employee_contribution': user[9],
#                 'pension_scheme_contribution': user[10],
#                 'edli_contribution': user[11],
#                 'pf_administrative_charges': user[12],
#                 'total_employer_pf_contribution': user[13],
#                 'total_deduction': user[14],
#                 "total_pf_amount": user[15],
#                 'gross_salary': user[16],
#                 'tds': user[17],
#                 'month_salary': user[18],
#                 'net_salary': user[19],
#                 "special_allowance": user[20],
#                 "full_name": user[21],
#                 "department": user[22],
#                 "role": user[23]
#             }
#             pf_list.append(pf_data)

#         return jsonify({'success': True, 'message': 'PF details retrieved successfully', 'data': pf_list}), 200

#     except Exception as e:
#         return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
        
 #################################### PF management ends here ######################################## 

 #################################### leave management starts here ######################################## 
 
@app.route('/get_leave', methods=['GET'])
def get_leave():
    try:
        # Retrieve pagination parameters from query string
        total_records = request.args.get('total_records', type=int)
        per_page = request.args.get('per_page', default=10, type=int)
        
        # If total_records is not provided, fetch it from the database
        if total_records is None:
            cursor = mysql.connection.cursor()
            cursor.execute("""SELECT COUNT(*) FROM leave_management WHERE is_active = 1""")
            total_records = cursor.fetchone()[0]
        
        # Calculate the total number of pages
        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1
        
        # Extract page number from the request
        page = request.args.get('page', default=1, type=int)
        
        # If the requested page is greater than the total pages, return empty data
        if page > total_pages:
            return jsonify({'success': False, 'message': 'Page not found', 'data': []}), 200
        
        # Calculate the offset
        offset = (page - 1) * per_page
        
        # If it's the last page and there are fewer records than per_page, adjust per_page
        if page == total_pages and total_records % per_page != 0:
            per_page = total_records % per_page
        
        cursor = mysql.connection.cursor()
        cursor.execute("""
            SELECT 
                lm.ref_employee_code, lm.leave_type, lm.start_date, lm.end_date, lm.reason, lm.status, lm.created_at, pi.full_name, pi.department, pi.role
            FROM 
                leave_management lm
            INNER JOIN 
                personal_information pi ON lm.ref_employee_code = pi.employee_code
            WHERE
                lm.is_active = 1
            ORDER BY lm.id DESC LIMIT %s OFFSET %s
        """, (per_page, offset))
        leave_applications = cursor.fetchall()
        cursor.close()
        
        leave_applications_data = []
        for leave_application in leave_applications:
            ref_employee_code, leave_type, start_date, end_date, reason, status, created_at, full_name, department, role = leave_application
            
            # Format dates as date, month, year
            start_date_str = start_date.strftime("%d-%m-%Y") if start_date else None
            end_date_str = end_date.strftime("%d-%m-%Y") if end_date else None
            created_at_str = created_at.strftime("%d-%m-%Y %H:%M:%S") if created_at else None
            
            leave_applications_data.append({
                'ref_employee_code': ref_employee_code,
                'leave_type': leave_type,
                'start_date': start_date_str,
                'end_date': end_date_str,
                'reason': reason,
                'status': status,
                'created_at': created_at_str,
                'full_name': full_name,
                'department': department,
                'role': role
            })
        
        return jsonify({
            'success': True,
            'message': 'Leave applications retrieved successfully',
            'page': page,
            'per_page': per_page,
            'total_records': total_records,
            'total_pages': total_pages,
            'data': leave_applications_data
        }), 200
    
    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/leave_details_date/<start_date>/<end_date>', methods=['GET'])
def leave_details_date(start_date, end_date):
    try:
        # Convert start_date and end_date to datetime objects
        start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date, '%Y-%m-%d').date()

        cursor = mysql.connection.cursor()

        # Call the stored procedure
        cursor.callproc('GetLeaveDetailsByDateRange', (start_date, end_date))

        # Fetch results from the stored procedure
        leave_data = cursor.fetchall()
        cursor.close()

        # If no leave applications found, return a custom message
        if not leave_data:
            return jsonify({'success': True, 'message': 'No leave applications found for the specified date range', 'data': []}), 200

        # Construct the response data
        response_data = []
        for leave_entry in leave_data:
            response_data.append({
                'ref_employee_code': leave_entry[0],
                'leave_type': leave_entry[1],
                'start_date': str(leave_entry[2]),
                'end_date': str(leave_entry[3]),
                'reason': leave_entry[4],
                'status': leave_entry[5],
                'created_by': leave_entry[6],
                'leave_document': leave_entry[7],
                'full_name': leave_entry[8],
                'department': leave_entry[9],
                'role': leave_entry[10]
            })

        return jsonify({'success': True, 'message': 'Leave search successful', 'data': response_data}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
  

@app.route('/get_leave_code/<employee_code>', methods=['GET'])
def get_leave_code(employee_code):
    try:
        per_page = request.args.get('per_page', default=10, type=int)
        page = request.args.get('page', default=1, type=int)

        cursor = mysql.connection.cursor()

        # Call the stored procedure
        cursor.callproc('GetLeaveApplicationsByCode', (employee_code, per_page, page))
        leave_applications = cursor.fetchall()

        # Get total records count
        cursor.execute("SELECT FOUND_ROWS();")
        total_records = cursor.fetchone()[0]

        total_pages = total_records // per_page if total_records > 0 else 0
        if total_records % per_page != 0:
            total_pages += 1

        if page > total_pages:
            return jsonify({'success': False, 'message': 'Page not found.', 'data': []}), 400

        leave_applications_data = []
        for leave_application in leave_applications:
            ref_employee_code, leave_type, start_date, end_date, reason, status, created_at, full_name, department, role = leave_application
            leave_applications_data.append({
                'ref_employee_code': ref_employee_code,
                'leave_type': leave_type,
                'start_date': str(start_date),
                'end_date': str(end_date),
                'reason': reason,
                'status': status,
                'created_at': str(created_at),
                'full_name': full_name,
                'department': department,
                'role': role
            })

        return jsonify({
            'success': True, 
            'message': 'Leave applications retrieved successfully', 
            'data': leave_applications_data, 
            'page': page, 
            'per_page': per_page, 
            'total_records': total_records, 
            'total_pages': total_pages
        }), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
        
 #################################### leave management ends here ######################################## 
 
# @app.route('/settings_api/<employee_code>', methods=['GET'])
# def settings_api(employee_code):
#     # Retrieve the employee code from the session
#     # employee_code = session.get('user', {}).get('employee_code')

#     # if not employee_code:
#     #     # If the employee code is not found in the session, return an error
#     #     return jsonify({"status": False, "message": "Unauthorized access"}), 401

#     try:
#         cursor = mysql.connection.cursor()
#         cursor.execute("SELECT * FROM personal_information WHERE employee_code = %s", (employee_code,))
#         info = cursor.fetchone()
#         cursor.close()
        
#         if info:
#             info_dict = {
#                 "employee_code": info[1],
#                 "full_name": info[2],
#                 "role": info[13]
#             }
#             return jsonify({"status": True, "message": 'Employee info retrieved', "data": info_dict}),200
#         else:
#             # Handle case when no employee is found
#             return jsonify({"status": False, "message": "Employee not found"}), 200

#     except Exception as e:
#         # Handle any unexpected errors
#         return jsonify({"status": False, "message": f"An error occurred: {str(e)}"}), 500
    
# @app.route('/uploads/<filename>')
# def uploaded_file(filename):
#     return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

@app.route('/settings_api/<employee_code>', methods=['GET'])
def settings_api(employee_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT * FROM personal_information WHERE employee_code = %s", (employee_code,))
        info = cursor.fetchone()
        cursor.close()
        
        if info:
            # Construct image URL with employee name
            profile_image_url = f"https://canteencard.in/projecthrms/personal_doc/{info[22]}"
            
            info_dict = {
                "employee_code": info[1],
                "full_name": info[2],
                "role": info[13],
                "profile_image": profile_image_url
            }
            return jsonify({"status": True, "message": 'Employee info retrieved', "data": info_dict})
        else:
            # Handle case when no employee is found
            return jsonify({"status": False, "message": "Employee not found"}), 404

    except Exception as e:
        # Handle any unexpected errors
        return jsonify({"status": False, "message": f"An error occurred: {str(e)}."}), 500 
 
################################################### pension management starts here #################################################### 

@app.route("/pension_contribution", methods=['POST'])
def pension_contribution():
    try:
        data = request.json
        employee_code = data.get('employee_code')
        basic_salary = int(data.get('basic_salary'))
        da = int(data.get('da'))
        
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT * FROM pension_contribution WHERE employee_code = %s and month(created_at) = month(curdate()) AND YEAR(created_at) = YEAR(CURDATE()) and is_active = 1", (employee_code,))
        data = cursor.fetchone()
        if data:
            return jsonify({'status':False,'message':'Pension already created for this month. You can update it.'}),400
        
        pensionable_salary = basic_salary + da
        
        if pensionable_salary > 15000:
            pensionable_salary = 15000

        employee_pf_contribution = round(pensionable_salary * 0.12,2)
        employer_pf_contribution = round(pensionable_salary * 0.0367,2)
        employer_pension_contribution = round((pensionable_salary * 0.0833),2)
        total_contribution = (employee_pf_contribution + employer_pf_contribution + employer_pension_contribution)
                
        # cursor = mysql.connection.cursor()
        cursor.callproc("get_pension_info", (employee_code,))
        pension = cursor.fetchone()
        cursor.close()
        uan = pension[3] if pension else None
        
        if not pension:
            return jsonify({'status': False, 'message': 'Employee not found.'}),404
        
        cursor = mysql.connection.cursor()
        cursor.callproc('insert_pension_contribution', (employee_code, uan, basic_salary, da, pensionable_salary, employee_pf_contribution, 
                                                        employer_pf_contribution, employer_pension_contribution, total_contribution))
        mysql.connection.commit()
        
        cursor.execute("SELECT * FROM pension_contribution WHERE employee_code = %s ORDER BY id DESC LIMIT 1", (employee_code,))
        contro = cursor.fetchone()
        cursor.close()
        
        response = {
            'employee_code': employee_code,
            'employee_name': pension[0],
            'designation': pension[1],
            'ctc': pension[2],
            'uan': pension[3],
            'basic_salary': contro[3],
            'da': contro[4],
            'pensionable_salary' : contro[5],
            'employee_pf_contribution': contro[6],
            'employer_pf_contribution': contro[7],
            'employer_pension_contribution': contro[8],
            'total_contribution': contro[9]
        }
        return jsonify({'status': True, 'data': response, 'message': 'Pension calculated successfully.'}),200
    
    except Exception as e:
        return jsonify({'status': False, 'message': f'Error Occurred: {str(e)}.'}), 500

@app.route("/update_pension_contribution/<employee_code>/<id>", methods=['PUT'])
def update_pension_contribution(employee_code,id):
    try:
        data = request.json
        basic_salary = int(data.get('basic_salary'))
        da = int(data.get('da'))
        
        pensionable_salary = basic_salary + da
        
        if pensionable_salary > 15000:
            pensionable_salary = 15000

        employee_pf_contribution = round(pensionable_salary * 0.12,2)
        employer_pf_contribution = round(pensionable_salary * 0.0367,2)
        employer_pension_contribution = round((pensionable_salary * 0.0833),2)
        total_contribution = (employee_pf_contribution + employer_pf_contribution + employer_pension_contribution)
        
        cursor = mysql.connection.cursor()
        cursor.callproc("get_pension_info", (employee_code,))
        pension = cursor.fetchone()
        cursor.close()
        uan = pension[3] if pension else None
        
        if not pension:
            return jsonify({"status": False, "message": 'Employee not found.'}),404
        
        cursor = mysql.connection.cursor()
        cursor.callproc('update_pension_contribution',(uan, basic_salary, da, pensionable_salary, employee_pf_contribution, employer_pf_contribution, 
                                                       employer_pension_contribution, total_contribution, employee_code, id))
        mysql.connection.commit()
        
        cursor.execute("SELECT * FROM pension_contribution WHERE employee_code = %s and id = %s", (employee_code,id))
        contro = cursor.fetchone()
        cursor.close()
        
        response = {
            'id': id,
            'employee_code': employee_code,
            'employee_name': pension[0],
            'designation': pension[1],
            'ctc': pension[2],
            'uan': pension[3],
            'basic_salary': contro[3],
            'da': contro[4],
            'pensionable_salary' : contro[5],
            'employee_pf_contribution': contro[6],
            'employer_pf_contribution': contro[7],
            'employer_pension_contribution': contro[8],
            'total_contribution': contro[9]
        }
        return jsonify({'status': True, 'data': response, 'message': 'Pension updated successfully.'}),200
    
    except Exception as e:
        return jsonify({'status': False, 'message': f'Error Occurred: {str(e)}.'}), 500
    
@app.route("/get_pension_contro", methods=['GET'])
def get_pension_contro():
    try:
        total_records = request.args.get('total_records',type=int)
        per_page = request.args.get('per_page',default=10,type=int)
        
        if total_records is None:
            cursor = mysql.connection.cursor()
            cursor.execute("""select count(*) from pension_contribution where is_active = 1""")
            total_records = cursor.fetchone()[0]
            
        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1
            
        page = request.args.get('page',default=1,type=int)
        
        if page > total_pages:
            return jsonify({"status":False,"message":'Page not found.',"data":[]}),200
        
        offset = (page-1) * per_page
        
        if page == total_pages and total_records % per_page != 0:
            per_page = total_records % per_page
    
        cursor = mysql.connection.cursor()
        cursor.callproc('get_pensioncontro_pagination',[per_page,offset])
        pension = cursor.fetchall()
        cursor.close()
        
        pension_list = []
        for list in pension:
            pension_data = {
                            "id":list[0],
                            "employee_code":list[1],
                            "uan_number":list[2],
                            "basic_salary":list[3],
                            "da":list[4],
                            "pensionable_salary":list[5],
                            "employee_pf_contribution":list[6],
                            "employer_pf_contribution":list[7],
                            "employer_pension_contribution":list[8],
                            "total_contribution":list[9],
                            "date":list[11].strftime("%d-%m-%Y")
                }
            pension_list.append(pension_data)
            
        return jsonify({'success': True, 
                        'message': 'Pension data retrieved successfully', 
                        'data': pension_list,
                        "page":page,
                        "per_page":per_page,
                        "total_pages":total_pages,
                        "total_records":total_records}),200    
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occurred: {str(e)}.'}),500
    
@app.route("/get_pension_contro_by_id/<employee_code>", methods=['GET'])
def pension_contro_by_id(employee_code):
    try:
        total_records = request.args.get('total_records',type=int)
        per_page = request.args.get('per_page',default=10,type=int)
        
        if total_records is None:
            cursor = mysql.connection.cursor()
            cursor.execute("""select count(*) from pension_contribution where is_active = 1 and employee_code = %s""",(employee_code,))
            total_records = cursor.fetchone()[0]
            
        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1
            
        page = request.args.get('page',default=1,type=int)
        
        if page > total_pages:
            return jsonify({"status":False,"message":'Page not found.',"data":[]}),200
        
        offset = (page-1) * per_page
        
        if page == total_pages and total_records % per_page != 0:
            per_page = total_records % per_page
            
        cursor = mysql.connection.cursor()
        cursor.callproc('get_pensioncontro_by_id',[employee_code,per_page,offset])
        pension = cursor.fetchall()
        cursor.close()
        
        pension_list = []
        for list in pension:
            pension_data = {
                            "id":list[0],
                            "employee_code":list[1],
                            "uan_number":list[2],
                            "basic_salary":list[3],
                            "da":list[4],
                            "pensionable_salary":list[5],
                            "employee_pf_contribution":list[6],
                            "employer_pf_contribution":list[7],
                            "employer_pension_contribution":list[8],
                            "total_contribution":list[9],
                            "date":list[11].strftime("%d-%m-%Y")
                }
            pension_list.append(pension_data)
            
        return jsonify({'success': True, 
                        'message': 'Pension data retrieved successfully', 
                        'data': pension_list,
                        "page":page,
                        "per_page":per_page,
                        "total_pages":total_pages,
                        "total_records":total_records}),200    
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occurred: {str(e)}.'}),500
    
@app.route("/prefill_pension_contro/<id>", methods=['GET'])
def prefill_pension_contro(id):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("select * from pension_contribution where id = %s and is_active = 1 order by id desc",(id,))
        pension = cursor.fetchall()
        cursor.close()
        
        pension_list = []
        for list in pension:
            pension_data = {
                            "id":list[0],
                            "emp_code":list[1],
                            "uan_number":list[2],
                            "basic_salary":list[3],
                            "da":list[4],
                            "Pensionable_salary":list[5],
                            "employee_pf_contribution":list[6],
                            "employer_pf_contribution":list[7],
                            "employer_pension_contribution":list[8],
                            "total_contribution":list[9],
                            "date":list[11].strftime("%Y-%m-%d")
                }
            pension_list.append(pension_data)
            
        return jsonify({"status":True,"message":'Displaying pension data.',"data":pension_data}),200    
    except Exception as e:
        return jsonify({"status":False,"message":f'Error occurred: {str(e)}.'}),500
    
@app.route('/delete_pension/<id>',methods=["DELETE"])
def delete_pension(id):
    
    cursor = mysql.connection.cursor()
    cursor.callproc('delete_pension_contro',[id])
    mysql.connection.commit()
    cursor.close()
    
    return jsonify({"status":True,
                    "message":"pension contribution deleted successfully",
                    "data": id}),200
    
@app.route("/monthly_pension", methods=['POST'])
def monthly_pension():
    try:
        data = request.json
        # Convert data to integers
        current_basic_salary = int(data.get('current_basic_salary'))
        current_da = int(data.get('current_da'))
        retirement_age = int(data.get('retirement_age'))
        service_period = int(data.get('service_period'))

        # Calculate pensionable_salary
        pensionable_salary = current_basic_salary + current_da

        retirement_type = data.get('retirement_type')
        
        if pensionable_salary > 15000:
            pensionable_salary = 15000
            
        if retirement_type == 'early_retirement':
            monthly_pension = (service_period * pensionable_salary)/70
            pension_reduction = 0.02 * (58 - retirement_age)
            monthly_pension = monthly_pension * (1 - pension_reduction)
        elif retirement_type == 'normal_retirement':
            monthly_pension = (service_period * pensionable_salary)/70
        else:
            monthly_pension = (service_period * pensionable_salary)/70
            pension_reduction = 0.04 * (retirement_age - 58)
            monthly_pension = monthly_pension * (1 + pension_reduction)
        
        data = {
                "current_basic_salary":current_basic_salary,
                "current_da":current_da,
                "retirement_age":retirement_age,
                "service_period":service_period,
                "retirement_type":retirement_type,
                "monthly_pension" : round(monthly_pension,2)
            }
        return jsonify({"status":True,"message":'Monthly pension calculated successfully.',"data":data}),200
            
    except Exception as e:
        return jsonify({"status":False,"message": f'Error occurred: {str(e)}.'}),500

################################################### pension management ends here #################################################### 

################################################### pension report starts here #################################################### 

@app.route("/pension_contri_report/<start_date>/<end_date>", methods = ['GET'])
def pension_contri_report(start_date,end_date):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("select * from pension_contribution where date(created_at) between %s and %s and is_active = 1 order by id desc",(start_date,end_date))
        pension = cursor.fetchall()
        cursor.close()
        
        pension_list = []
        for list in pension:
            pension_data = {
                            "id":list[0],
                            "emp_code":list[1],
                            "uan_number":list[2],
                            "basic_salary":list[3],
                            "da":list[4],
                            "Pensionable_salary":list[5],
                            "employee_pf_contribution":list[6],
                            "employer_pf_contribution":list[7],
                            "employer_pension_contribution":list[8],
                            "total_contribution":list[9],
                            "date":list[11].strftime("%Y-%m-%d")
                }
            pension_list.append(pension_data)
            
        return jsonify({"status":True,"message":'Displaying pension data.',"data":pension_list}),200
    except Exception as e:
        return jsonify({"status": False,"message":f'Error occurred: {str(e)}.'})
    
# @app.route("/pension_module_report/<start_date>/<end_date>", methods = ['GET'])
# def pension_module_report(start_date,end_date):
#     try:
#         cursor = mysql.connection.cursor()
#         cursor.execute("select * from pension_module where date(created_at) between %s and %s and is_active = 1 order by id desc",(start_date,end_date))
#         pension = cursor.fetchall()
#         cursor.close()
        
#         pension_list = []
#         for list in pension:
#             pension_data = {
#                     'id':list[0],
#                     'emp_code': list[1],
#                     "emp_name": list[2],
#                     "uan_number": list[3],
#                     "emp_age": list[4],
#                     "emp_address": list[6],
#                     "emp_aadhar_num": list[7],
#                     "emp_email_id": list[5],
#                     "emp_phone_num": list[8],
#                     "emp_pan_num": list[9],
#                     "emp_gender": list[10],
#                     "emp_designation": list[11],
#                     "marriage_status": list[12],
#                     "date_of_birth": list[13].strftime('%Y-%m-%d'),
#                     "date_of_joining": list[14].strftime('%Y-%m-%d'),
#                     "bank_name": list,
#                     "bank_acc_no": list,
#                     "bank_ifsc_code": list,
#                     "ctc": list[15],
#                     "nationality": list[16],
#                     "nominee_name": list[17],
#                     "nominee_phone_num": list,
#                     "nominee_address": list,
#                     "nominee_aadhar_num": list,
#                     "relationship": list,
#                     "nominee_aadhar_card": list,
#                     "emp_aadhar_card": list,
#                     "emp_bank_details": list,
#                     "emp_pan_card": list,
#                 }
#             pension_list.append(pension_data)
            
#         return jsonify({"status":True,"message":'Displaying pension data.',"data":pension_list}),200
#     except Exception as e:
#         return jsonify({"status": False,"message":f'Error occurred: {str(e)}.'})
    
@app.route('/count_active_pension', methods=['GET'])
def count_active_pension():
    try:
        cursor = mysql.connection.cursor()

        # Count the number of active grievances for all employees
        cursor.execute("""
            SELECT COUNT(*) AS active_pensioners FROM pension_module WHERE is_active = 1
        """)
        result = cursor.fetchone()
        active_pensioner_count = result[0] if result else 0

        cursor.close()

        return jsonify({'success': True, 'message': 'Active pensioners count retrieved successfully', 'data': active_pensioner_count}), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500
    
################################################### pension report ends here #################################################### 
################################################### pension details starts here ####################################################

UPLOAD_FOLDER_PENSION = r"/home/fi2e8gs31z4n/projecthrms/pension_doc"
app.config['UPLOAD_FOLDER_PENSION'] = UPLOAD_FOLDER_PENSION

@app.route('/pension_module', methods=['POST'])
def pension_module():
    if request.method == 'POST':
        try:
            # Extract data from form payload
            emp_code = request.form.get('emp_code')
            emp_name = request.form.get('emp_name')
            uan_number = request.form.get('uan_number')
            emp_age = request.form.get('emp_age')
            emp_address = request.form.get('emp_address')
            emp_aadhar_num = request.form.get('emp_aadhar_num')
            emp_pan_num = request.form.get('emp_pan_num')
            emp_email_id = request.form.get('emp_email_id')
            emp_phone_num = request.form.get('emp_phone_num')
            emp_gender = request.form.get('emp_gender')
            emp_designation = request.form.get('emp_designation')
            marriage_status = request.form.get('marriage_status')
            date_of_birth_str = request.form.get('date_of_birth')
            date_of_joining_str = request.form.get('date_of_joining')
            bank_name = request.form.get('bank_name')
            bank_acc_no = request.form.get('bank_acc_no')
            bank_ifsc_code = request.form.get('bank_ifsc_code')
            bank_branch=request.form.get('bank_branch')
            ctc = float(request.form.get("ctc"))
            nationality = request.form.get('nationality')
            nominee_name = request.form.get('nominee_name')
            nominee_phone_num = request.form.get('nominee_phone_num')
            nominee_address = request.form.get('nominee_address')
            nominee_aadhar_num = request.form.get('nominee_aadhar_num')
            relationship = request.form.get('relationship')

            # Validate date fields
            if not date_of_birth_str or not date_of_joining_str:
                return jsonify({"success": False, "error": "Date of birth and date of joining are required"}), 400

            date_of_birth = datetime.strptime(date_of_birth_str, '%Y-%m-%d').date()
            date_of_joining = datetime.strptime(date_of_joining_str, '%Y-%m-%d').date()

            # Check if the uan_number already exists
            cursor = mysql.connection.cursor()
            cursor.execute("SELECT COUNT(*) FROM pension_module WHERE uan_number = %s", (uan_number,))
            count = cursor.fetchone()[0]
            cursor.close()

            if count > 0:
                return jsonify({"success": False, "error": "UAN number already exists"}), 400

            # Function to save uploaded files
            def save_file(file, filename_prefix):
                if file and allowed_file(file.filename):
                    file_extension = os.path.splitext(file.filename)[1]
                    filename = f"{emp_code}_{filename_prefix}{file_extension}"
                    file.save(os.path.join(app.config['UPLOAD_FOLDER_PENSION'], filename))
                    return filename
                return None

            # Handle file uploads
            nominee_aadhar = request.files.get('nominee_aadhar_card')
            nominee_aadhar_card_filename = save_file(nominee_aadhar, 'nominee_aadhar_card')

            emp_aadhar = request.files.get('emp_aadhar_card')
            emp_aadhar_card_filename = save_file(emp_aadhar, 'emp_aadhar_card')

            emp_bank_details = request.files.get('emp_bank_details')
            emp_bank_details_filename = save_file(emp_bank_details, 'emp_bank_details')

            emp_pan = request.files.get('emp_pan_card')
            emp_pan_card_filename = save_file(emp_pan, 'emp_pan_card')

            # Insert data into pension_module table
            cursor = mysql.connection.cursor()
            cursor.callproc('InsertPensionDetails', (
                emp_code, emp_name, uan_number, emp_age, emp_address, emp_aadhar_num, emp_pan_num, emp_email_id, emp_phone_num, emp_gender, emp_designation, marriage_status, date_of_birth, date_of_joining, bank_name, bank_acc_no, bank_ifsc_code, bank_branch, ctc, nationality, nominee_name, nominee_phone_num, nominee_address, nominee_aadhar_num, relationship, nominee_aadhar_card_filename, emp_aadhar_card_filename, emp_bank_details_filename, emp_pan_card_filename
            ))

            # Commit the transaction to persist the changes to the database
            mysql.connection.commit()
            cursor.close()


            response_data = {
                "success": True,
                "message": "Pension details added successfully",
                "data": {
                    'emp_code': emp_code,
                    "emp_name": emp_name,
                    "uan_number": uan_number,
                    "emp_age": emp_age,
                    "emp_address": emp_address,
                    "emp_aadhar_num": emp_aadhar_num,
                    "emp_email_id": emp_email_id,
                    "emp_phone_num": emp_phone_num,
                    "emp_pan_num": emp_pan_num,
                    "emp_gender": emp_gender,
                    "emp_designation": emp_designation,
                    "marriage_status": marriage_status,
                    "date_of_birth": date_of_birth.strftime('%d-%m-%Y'),
                    "date_of_joining": date_of_joining.strftime('%d-%m-%Y'),
                    "bank_name": bank_name,
                    "bank_acc_no": bank_acc_no,
                    "bank_ifsc_code": bank_ifsc_code,
                    "bank_branch":bank_branch,
                    "ctc": ctc,
                    "nationality": nationality,
                    "nominee_name": nominee_name,
                    "nominee_phone_num": nominee_phone_num,
                    "nominee_address": nominee_address,
                    "nominee_aadhar_num": nominee_aadhar_num,
                    "relationship": relationship,
                    "nominee_aadhar_card": nominee_aadhar_card_filename,
                    "emp_aadhar_card": emp_aadhar_card_filename,
                    "emp_bank_details": emp_bank_details_filename,
                    "emp_pan_card": emp_pan_card_filename,
                }
            }

            return jsonify(response_data), 200

        except Exception as e:
            error_message = "Error occurred while adding pension details: {}".format(str(e))
            app.logger.error(error_message)
            return jsonify({"success": False, "error": error_message}), 500

    # If the request method is not POST, return a 405 Method Not Allowed error
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts POST requests"}), 405
    
@app.route('/pension_details', methods=['GET'])
def pension_pagination():
    try:
        total_records = request.args.get('total_records', type=int)
        per_page = request.args.get('per_page', default=10, type=int)

        if total_records is None:
            cursor = mysql.connection.cursor()
            cursor.execute("""SELECT COUNT(*) FROM pension_module WHERE is_active = 1""")
            total_records = cursor.fetchone()[0]

        total_pages = total_records // per_page
        if total_records % per_page != 0:
            total_pages += 1

        page = request.args.get('page', default=1, type=int)

        if page > total_pages:
            return jsonify({"status": False, "message": 'Page not found.', "data": []}), 200

        offset = (page - 1) * per_page

        if page == total_pages and total_records % per_page != 0:
            per_page = total_records % per_page

        # Prepare to call the stored procedure with an output parameter for total records
        cursor = mysql.connection.cursor()
        cursor.callproc('GetPensionModulePagination', (per_page, offset))
        pension_data = cursor.fetchall()
        cursor.close()

        pension_list = []
        for pension in pension_data:
            (emp_code, emp_name, uan_number, emp_age, emp_email_id, emp_address, emp_aadhar_num, emp_phone_num,
             emp_pan_num, emp_gender, emp_designation, marriage_status, date_of_birth, date_of_joining, bank_name,
             bank_acc_no, bank_ifsc_code, bank_branch, ctc, nationality, nominee_name, nominee_phone_num,
             nominee_address, nominee_aadhar_num, relationship, nominee_aadhar_card, emp_aadhar_card,
             emp_bank_details, emp_pan_card) = pension


            pension_list.append({
                'emp_code': emp_code,
                'emp_name': emp_name,
                'uan_number': uan_number,
                'emp_age': emp_age,
                'emp_email_id': emp_email_id,
                'emp_address': emp_address,
                'emp_aadhar_num': emp_aadhar_num,
                'emp_phone_num': emp_phone_num,
                'emp_pan_num': emp_pan_num,
                'emp_gender': emp_gender,
                'emp_designation': emp_designation,
                'marriage_status': marriage_status,
                'date_of_birth': datetime.strptime(pension[12], '%Y-%m-%d').strftime('%d-%m-%Y'),
                'date_of_joining': datetime.strptime(pension[13], '%Y-%m-%d').strftime('%d-%m-%Y'),
                'bank_name': bank_name,
                'bank_acc_no': bank_acc_no,
                'bank_ifsc_code': bank_ifsc_code,
                'bank_branch': bank_branch,
                'ctc': ctc,
                'nationality': nationality,
                'nominee_name': nominee_name,
                'nominee_phone_num': nominee_phone_num,
                'nominee_address': nominee_address,
                'nominee_aadhar_num': nominee_aadhar_num,
                'relationship': relationship,
                'nominee_aadhar_card': nominee_aadhar_card,
                'emp_aadhar_card': emp_aadhar_card,
                'emp_bank_details': emp_bank_details,
                'emp_pan_card': emp_pan_card
            })

        return jsonify({
            'success': True,
            'message': 'Pension details retrieved successfully',
            'page': page,
            'per_page': per_page,
            'total_records': total_records,
            'total_pages': total_pages,
            'data': pension_list
        }), 200

    except Exception as e:
        return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

@app.route('/pension_doc/<filename>')
def uploaded_file_pension(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER_PENSION'], filename)

@app.route('/pension_based_id/<emp_code>', methods=['GET'])
def get_by_code(emp_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.callproc('GetPensionDetailsByCode', (emp_code,))
        pension_data = cursor.fetchone()
        cursor.close()

        if pension_data is None:
            return jsonify({'status': False, 'message': f'Pension details not found for emp_code {emp_code}'}), 404

        pension_details = {
            'emp_code': pension_data[0],
            'emp_name': pension_data[1],
            'uan_number': pension_data[2],
            'emp_age': pension_data[3],
            'emp_email_id': pension_data[4],
            'emp_address': pension_data[5],
            'emp_aadhar_num': pension_data[6],
            'emp_phone_num': pension_data[7],
            'emp_pan_num': pension_data[8],
            'emp_gender': pension_data[9],
            'emp_designation': pension_data[10],
            'marriage_status': pension_data[11],
            'date_of_birth': str(pension_data[12]),
            'date_of_joining': str(pension_data[13]),
            'bank_name': pension_data[14],
            'bank_acc_no': pension_data[15],
            'bank_ifsc_code': pension_data[16],
            'bank_branch': pension_data[17] if pension_data[17] is not None else "Unknown",
            'ctc': pension_data[18],
            'nationality': pension_data[19],
            'nominee_name': pension_data[20],
            'nominee_phone_num': pension_data[21],
            'nominee_address': pension_data[22],
            'nominee_aadhar_num': pension_data[23],
            'relationship': pension_data[24],
            
            'nominee_aadhar_card': url_for('uploaded_file_pension', filename=pension_data[25], _external=True) if pension_data[25] else None,
            'emp_aadhar_card': url_for('uploaded_file_pension', filename=pension_data[26], _external=True) if pension_data[26] else None,
            'emp_bank_details': url_for('uploaded_file_pension', filename=pension_data[27], _external=True) if pension_data[27] else None,
            'emp_pan_card': url_for('uploaded_file_pension', filename=pension_data[28], _external=True) if pension_data[28] else None,
        }

        return jsonify({
            "status": True,
            "message": "Pension details found",
            "data": pension_details
        }), 200

    except Exception as e:
        return jsonify({'status': False, 'message': f'An error occurred: {str(e)}'}), 500
    
@app.route('/update_pension/<emp_code>', methods=['PUT'])
def update_pension_details(emp_code):
    if request.method == 'PUT':
        try:
            # Extract data from form payload
            emp_name = request.form.get('emp_name')
            uan_number = request.form.get('uan_number')
            emp_age = request.form.get('emp_age')
            emp_address = request.form.get('emp_address')
            emp_aadhar_num = request.form.get('emp_aadhar_num')
            emp_pan_num = request.form.get('emp_pan_num')
            emp_email_id = request.form.get('emp_email_id')
            emp_phone_num = request.form.get('emp_phone_num')
            emp_gender = request.form.get('emp_gender')
            emp_designation = request.form.get('emp_designation')
            marriage_status = request.form.get('marriage_status')
            date_of_birth_str = request.form.get('date_of_birth')
            date_of_joining_str = request.form.get('date_of_joining')
            bank_name = request.form.get('bank_name')
            bank_acc_no = request.form.get('bank_acc_no')
            bank_ifsc_code = request.form.get('bank_ifsc_code')
            bank_branch = request.form.get('bank_branch')
            ctc = float(request.form.get("ctc"))
            nationality = request.form.get('nationality')
            nominee_name = request.form.get('nominee_name')
            nominee_phone_num = request.form.get('nominee_phone_num')
            nominee_address = request.form.get('nominee_address')
            nominee_aadhar_num = request.form.get('nominee_aadhar_num')
            relationship = request.form.get('relationship')

            # Validate date fields
            if not date_of_birth_str or not date_of_joining_str:
                return jsonify({"success": False, "error": "Date of birth and date of joining are required"}), 400

            date_of_birth = datetime.strptime(date_of_birth_str, '%Y-%m-%d').date()
            date_of_joining = datetime.strptime(date_of_joining_str, '%Y-%m-%d').date()

            # Check if the emp_code exists and get the existing file names
            cursor = mysql.connection.cursor()
            cursor.execute("SELECT * FROM pension_module WHERE emp_code = %s", (emp_code,))
            user = cursor.fetchone()

            if not user:
                return jsonify({"success": False, "error": "Employee with emp_code {} does not exist".format(emp_code)}), 404

            existing_nominee_aadhar_card = user[26]  # Assuming nominee_aadhar_card is at index 26 in the database table
            existing_emp_aadhar_card = user[27]  # Assuming emp_aadhar_card is at index 27
            existing_emp_bank_details = user[28]  # Assuming emp_bank_details is at index 28
            existing_emp_pan_card = user[29]  # Assuming emp_pan_card is at index 29

            # Function to save uploaded files
            def save_file(file, filename_prefix, existing_filename):
                if file and allowed_file(file.filename):
                    file_extension = os.path.splitext(file.filename)[1]
                    filename = f"{emp_code}_{filename_prefix}{file_extension}"
                    file.save(os.path.join(app.config['UPLOAD_FOLDER_PENSION'], filename))
                    return filename
                return existing_filename

            # Handle file uploads
            nominee_aadhar = request.files.get('nominee_aadhar_card')
            nominee_aadhar_card_filename = save_file(nominee_aadhar, 'nominee_aadhar_card', existing_nominee_aadhar_card)

            emp_aadhar = request.files.get('emp_aadhar_card')
            emp_aadhar_card_filename = save_file(emp_aadhar, 'emp_aadhar_card', existing_emp_aadhar_card)

            emp_bank_details = request.files.get('emp_bank_details')
            emp_bank_details_filename = save_file(emp_bank_details, 'emp_bank_details', existing_emp_bank_details)

            emp_pan = request.files.get('emp_pan_card')
            emp_pan_card_filename = save_file(emp_pan, 'emp_pan_card', existing_emp_pan_card)

            # Call the stored procedure to update data in pension_module table
            cursor.callproc('UpdatePensionDetails', (
                emp_code, emp_name, uan_number, emp_age, emp_email_id, emp_address, emp_aadhar_num, emp_phone_num,
                emp_pan_num, emp_gender, emp_designation, marriage_status, date_of_birth, date_of_joining, bank_name,
                bank_acc_no, bank_ifsc_code, bank_branch, ctc, nationality, nominee_name, nominee_phone_num,
                nominee_address, nominee_aadhar_num, relationship, nominee_aadhar_card_filename, emp_aadhar_card_filename,
                emp_bank_details_filename, emp_pan_card_filename))

            # Commit the transaction to persist the changes to the database
            mysql.connection.commit()
            cursor.close()

            # Format dates for response
            date_of_birth_formatted = date_of_birth.strftime("%d-%m-%Y")
            date_of_joining_formatted = date_of_joining.strftime("%d-%m-%Y")

            response_data = {
                "success": True,
                "message": "Pension details updated successfully",
                "data": {
                    'emp_code': emp_code,
                    "emp_name": emp_name,
                    "uan_number": uan_number,
                    "emp_age": emp_age,
                    "emp_address": emp_address,
                    "emp_aadhar_num": emp_aadhar_num,
                    "emp_email_id": emp_email_id,
                    "emp_phone_num": emp_phone_num,
                    "emp_pan_num": emp_pan_num,
                    "emp_gender": emp_gender,
                    "emp_designation": emp_designation,
                    "marriage_status": marriage_status,
                    "date_of_birth": date_of_birth_formatted,
                    "date_of_joining": date_of_joining_formatted,
                    "bank_name": bank_name,
                    "bank_acc_no": bank_acc_no,
                    "bank_ifsc_code": bank_ifsc_code,
                    "bank_branch": bank_branch,
                    "ctc": ctc,
                    "nationality": nationality,
                    "nominee_name": nominee_name,
                    "nominee_phone_num": nominee_phone_num,
                    "nominee_address": nominee_address,
                    "nominee_aadhar_num": nominee_aadhar_num,
                    "relationship": relationship,
                    "nominee_aadhar_card": nominee_aadhar_card_filename,
                    "emp_aadhar_card": emp_aadhar_card_filename,
                    "emp_bank_details": emp_bank_details_filename,
                    "emp_pan_card": emp_pan_card_filename,
                }
            }

            return jsonify(response_data), 200

        except Exception as e:
            error_message = "Error occurred while updating pension details: {}".format(str(e))
            app.logger.error(error_message)
            return jsonify({"success": False, "error": error_message}), 500

    # If the request method is not PUT, return a 405 Method Not Allowed error
    return jsonify({"error": "Method Not Allowed", "message": "This endpoint only accepts PUT requests"}), 405

@app.route('/delete_pension_employee/<emp_code>', methods=["DELETE"])
def delete_pension_employee(emp_code):
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT * FROM pension_module WHERE emp_code = %s", (emp_code,))
        user = cursor.fetchone()
        
        if not user:
            return jsonify({"status": False, "message": "Employee ID not found.", "error": "Employee ID not found."})
        
        cursor.execute('UPDATE pension_module SET is_active = 0 WHERE emp_code = %s', (emp_code,))
        mysql.connection.commit()
        cursor.close()
        
        return jsonify({"status": True, "message": "Employee deactivated successfully", "data": emp_code})
    
    except Exception as e:
        return jsonify({'status': False, 'message': f'An error occurred: {str(e)}'}), 500
################################################### pension details ends here ####################################################

@app.route('/employee_codes_names', methods=['GET'])
def get_employee_codes_names():
    try:
        cursor = mysql.connection.cursor()
        cursor.execute("SELECT employee_code, full_name FROM personal_information where is_active = 1")
        employees = cursor.fetchall()
        cursor.close()
        
        if not employees:
            return jsonify({"status": False, "message": "No employees found"}), 404
        
        employee_list = [{"value": f"{emp[0]}-{emp[1]}"} for emp in employees]

        return jsonify({"status": True, "data": employee_list}), 200

    except Exception as e:
        return jsonify({"status": False, "message": 'Error occurred.', "error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
      
